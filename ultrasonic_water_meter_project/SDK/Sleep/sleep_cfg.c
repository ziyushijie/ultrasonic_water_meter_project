#include "sleep_cfg.h"

//===全局变量定义
SLEEP_HandleType		g_sleep_one = { 0 };
pSLEEP_HandleType		p_sleep_one = &g_sleep_one;

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t sleep_tick_init(uint32_t(*func_time_tick)(void))
{
	//---注册滴答函数
	(func_time_tick != NULL) ?
		(p_sleep_one->msg_f_time_tick = func_time_tick) :
		(p_sleep_one->msg_f_time_tick = sys_tick_task_get_tick);
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t sleep_init(uint32_t(*func_time_tick)(void))
{
	//--->>>配置端口中断---开始
	//---不使能中断
	PMK1 = 1U;
	//---清楚中断标志
	PIF1 = 0U;

	//---设置中断优先级
	PPR11 = 0U;
	PPR01 = 1U;

	//---屏蔽下降沿中断允许寄存器
	EGN0 &= ~_02_INTP1_EDGE_FALLING_SEL;
	//---使能上升沿触发中断
	EGP0 |= _02_INTP1_EDGE_RISING_SEL;

	//---设置Key为输入模式且上拉使能,红外串口的输入中断端口
	gpio_task_pin_mode_input(GPIOP5, GPIO_PIN_BIT_2);
	gpio_task_pin_mode_pull_up_set(GPIOP5, GPIO_PIN_BIT_2);

	////---清楚中断标志
	//PIF1 = 0U;
	////---使能中断
	//PMK1 = 0U;
	//---注册滴答函数
	(func_time_tick != NULL) ?
		(p_sleep_one->msg_f_time_tick = func_time_tick) :
		(p_sleep_one->msg_f_time_tick = sys_tick_task_get_tick);

	p_sleep_one->msg_mode = 0;
	p_sleep_one->msg_wakeup = SLEEP_WAKEUP_NONE;
	p_sleep_one->msg_wakeup_record = p_sleep_one->msg_f_time_tick();

	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t sleep_get(void)
{
	return p_sleep_one->msg_mode;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t sleep_enter(void)
{
	p_sleep_one->msg_wakeup = SLEEP_WAKEUP_NONE;
	p_sleep_one->msg_mode = 1;
	//---不使能其他外设设备提供副系统时钟
	//OSMC = _80_CGC_SUBINHALT_OFF | _00_CGC_RTC_IT_LCD_CLK_FSUB;
	//---映射INTP7中断到串口的接收P43上
	//gpio_task_pin_mode_ior_set(GPIOP0, GPIO_PIN_BIT_4);
	//--->>>开启INT1中断
	//---清除中断标识
	PIF1 = 0U;
	//---使能中断
	PMK1 = 0U;

	//--->>>开启INT7中断
	//---清除中断标识
	PIF7 = 0U;
	//---使能中断
	PMK7 = 0U;
	
	//---清楚中断标志
	PIF0 = 0U;
	//---不使能中断
	PMK0 = 0U;

	//---喂狗，避免看门狗复位
	WDT_RESET();
	//---进入STOP模式
	STOP();
	//---更新唤醒时间
	//p_sleep_one->msg_wakeup_record = p_sleep_one->msg_f_time_tick();
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t sleep_exit(void)
{
	//---退出休眠模式
	p_sleep_one->msg_mode = 0;
	//---映射INTP7中断到MS1022的中断上
	gpio_task_pin_mode_ior_reset(GPIOP0, GPIO_PIN_BIT_4);
	//---使能其他外设设备提供副系统时钟
	//OSMC = _00_CGC_SUBINHALT_ON | _00_CGC_RTC_IT_LCD_CLK_FSUB;
	//---唤醒时间
	//p_sleep_one->msg_wakeup_record = p_sleep_one->msg_f_time_tick();
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t sleep_wakeup_get(void)
{
	return p_sleep_one->msg_wakeup;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t sleep_wakeup_set(uint8_t wakeup)
{
	p_sleep_one->msg_wakeup =wakeup;
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t sleep_wakeup_record_set(uint32_t wakeup_record)
{
	p_sleep_one->msg_wakeup_record = wakeup_record;
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint32_t sleep_wakeup_record_get(void)
{
	return p_sleep_one->msg_wakeup_record;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 唤醒退出
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t sleep_wakeup_exit(uint8_t wakeup)
{
	sleep_exit();
	return sleep_wakeup_set(wakeup);
}