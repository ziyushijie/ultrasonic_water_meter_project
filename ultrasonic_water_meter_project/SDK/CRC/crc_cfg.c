#include "crc_cfg.h"

//===CRC使用的滴答定时
uint32_t(*crc_time_tick)(void);

#if defined(CRC_ENABLE_CRC32)
//===CRC32表---计算种子0x04C11DB7---计算方程式g(x) = x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1
const uint32_t  g_crc32_table_mpeg_2[256] =
{
	0x00000000,0x04C11DB7,0x09823B6E,0x0D4326D9,0x130476DC,0x17C56B6B,0x1A864DB2,0x1E475005,
	0x2608EDB8,0x22C9F00F,0x2F8AD6D6,0x2B4BCB61,0x350C9B64,0x31CD86D3,0x3C8EA00A,0x384FBDBD,
	0x4C11DB70,0x48D0C6C7,0x4593E01E,0x4152FDA9,0x5F15ADAC,0x5BD4B01B,0x569796C2,0x52568B75,
	0x6A1936C8,0x6ED82B7F,0x639B0DA6,0x675A1011,0x791D4014,0x7DDC5DA3,0x709F7B7A,0x745E66CD,
	0x9823B6E0,0x9CE2AB57,0x91A18D8E,0x95609039,0x8B27C03C,0x8FE6DD8B,0x82A5FB52,0x8664E6E5,
	0xBE2B5B58,0xBAEA46EF,0xB7A96036,0xB3687D81,0xAD2F2D84,0xA9EE3033,0xA4AD16EA,0xA06C0B5D,
	0xD4326D90,0xD0F37027,0xDDB056FE,0xD9714B49,0xC7361B4C,0xC3F706FB,0xCEB42022,0xCA753D95,
	0xF23A8028,0xF6FB9D9F,0xFBB8BB46,0xFF79A6F1,0xE13EF6F4,0xE5FFEB43,0xE8BCCD9A,0xEC7DD02D,
	0x34867077,0x30476DC0,0x3D044B19,0x39C556AE,0x278206AB,0x23431B1C,0x2E003DC5,0x2AC12072,
	0x128E9DCF,0x164F8078,0x1B0CA6A1,0x1FCDBB16,0x018AEB13,0x054BF6A4,0x0808D07D,0x0CC9CDCA,
	0x7897AB07,0x7C56B6B0,0x71159069,0x75D48DDE,0x6B93DDDB,0x6F52C06C,0x6211E6B5,0x66D0FB02,
	0x5E9F46BF,0x5A5E5B08,0x571D7DD1,0x53DC6066,0x4D9B3063,0x495A2DD4,0x44190B0D,0x40D816BA,
	0xACA5C697,0xA864DB20,0xA527FDF9,0xA1E6E04E,0xBFA1B04B,0xBB60ADFC,0xB6238B25,0xB2E29692,
	0x8AAD2B2F,0x8E6C3698,0x832F1041,0x87EE0DF6,0x99A95DF3,0x9D684044,0x902B669D,0x94EA7B2A,
	0xE0B41DE7,0xE4750050,0xE9362689,0xEDF73B3E,0xF3B06B3B,0xF771768C,0xFA325055,0xFEF34DE2,
	0xC6BCF05F,0xC27DEDE8,0xCF3ECB31,0xCBFFD686,0xD5B88683,0xD1799B34,0xDC3ABDED,0xD8FBA05A,
	0x690CE0EE,0x6DCDFD59,0x608EDB80,0x644FC637,0x7A089632,0x7EC98B85,0x738AAD5C,0x774BB0EB,
	0x4F040D56,0x4BC510E1,0x46863638,0x42472B8F,0x5C007B8A,0x58C1663D,0x558240E4,0x51435D53,
	0x251D3B9E,0x21DC2629,0x2C9F00F0,0x285E1D47,0x36194D42,0x32D850F5,0x3F9B762C,0x3B5A6B9B,
	0x0315D626,0x07D4CB91,0x0A97ED48,0x0E56F0FF,0x1011A0FA,0x14D0BD4D,0x19939B94,0x1D528623,
	0xF12F560E,0xF5EE4BB9,0xF8AD6D60,0xFC6C70D7,0xE22B20D2,0xE6EA3D65,0xEBA91BBC,0xEF68060B,
	0xD727BBB6,0xD3E6A601,0xDEA580D8,0xDA649D6F,0xC423CD6A,0xC0E2D0DD,0xCDA1F604,0xC960EBB3,
	0xBD3E8D7E,0xB9FF90C9,0xB4BCB610,0xB07DABA7,0xAE3AFBA2,0xAAFBE615,0xA7B8C0CC,0xA379DD7B,
	0x9B3660C6,0x9FF77D71,0x92B45BA8,0x9675461F,0x8832161A,0x8CF30BAD,0x81B02D74,0x857130C3,
	0x5D8A9099,0x594B8D2E,0x5408ABF7,0x50C9B640,0x4E8EE645,0x4A4FFBF2,0x470CDD2B,0x43CDC09C,
	0x7B827D21,0x7F436096,0x7200464F,0x76C15BF8,0x68860BFD,0x6C47164A,0x61043093,0x65C52D24,
	0x119B4BE9,0x155A565E,0x18197087,0x1CD86D30,0x029F3D35,0x065E2082,0x0B1D065B,0x0FDC1BEC,
	0x3793A651,0x3352BBE6,0x3E119D3F,0x3AD08088,0x2497D08D,0x2056CD3A,0x2D15EBE3,0x29D4F654,
	0xC5A92679,0xC1683BCE,0xCC2B1D17,0xC8EA00A0,0xD6AD50A5,0xD26C4D12,0xDF2F6BCB,0xDBEE767C,
	0xE3A1CBC1,0xE760D676,0xEA23F0AF,0xEEE2ED18,0xF0A5BD1D,0xF464A0AA,0xF9278673,0xFDE69BC4,
	0x89B8FD09,0x8D79E0BE,0x803AC667,0x84FBDBD0,0x9ABC8BD5,0x9E7D9662,0x933EB0BB,0x97FFAD0C,
	0xAFB010B1,0xAB710D06,0xA6322BDF,0xA2F33668,0xBCB4666D,0xB8757BDA,0xB5365D03,0xB1F740B4
};

//===
const uint32_t  g_crc32_table_iso_hdlc[256] = 
{
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
	0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
};
#endif // CRC_USE_CRC32

#ifdef CRC_ENABLE_CRC16
//===CRC16表---计算种子0x1021---计算方程式g(x) = x16+x12+x5+x0
const uint16_t  g_crc16_table_1021h[256] =
{
	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
	0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
	0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
	0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
	0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
	0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
	0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
	0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
	0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
	0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
	0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
	0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
	0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
	0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
	0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
	0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
	0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
	0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
	0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
	0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
	0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
	0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
	0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
	0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
	0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
	0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
	0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
	0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
	0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
	0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
	0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
	0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
};

//===CRC16表---计算种子0xA001---计算方程式g(x) = x16+x15+x0
const uint16_t  g_crc16_table_a001h[256] = 
{                                 
	0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,   
	0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,   
	0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,   
	0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,   
	0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,   
	0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,   
	0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,   
	0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,   
	0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,   
	0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,   
	0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,   
	0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,   
	0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,   
	0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,   
	0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,   
	0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,   
	0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 
	0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,   
	0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,   
	0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,   
	0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,   
	0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,   
	0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,   
	0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,   
	0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,   
	0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,   
	0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,   
	0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,   
	0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,   
	0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,   
	0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,   
	0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
};
//===CRC16表---计算种子0x8005---计算方程式g(x) = x16+x15+x2+x0
const uint16_t g_crc16_table_8005h[256] = 
{
	0x0000, 0x8005, 0x800F, 0x000A, 0x801B, 0x001E, 0x0014, 0x8011,
	0x8033, 0x0036, 0x003C, 0x8039, 0x0028, 0x802D, 0x8027, 0x0022,
	0x8063, 0x0066, 0x006C, 0x8069, 0x0078, 0x807D, 0x8077, 0x0072,
	0x0050, 0x8055, 0x805F, 0x005A, 0x804B, 0x004E, 0x0044, 0x8041,
	0x80C3, 0x00C6, 0x00CC, 0x80C9, 0x00D8, 0x80DD, 0x80D7, 0x00D2,
	0x00F0, 0x80F5, 0x80FF, 0x00FA, 0x80EB, 0x00EE, 0x00E4, 0x80E1,
	0x00A0, 0x80A5, 0x80AF, 0x00AA, 0x80BB, 0x00BE, 0x00B4, 0x80B1,
	0x8093, 0x0096, 0x009C, 0x8099, 0x0088, 0x808D, 0x8087, 0x0082,
	0x8183, 0x0186, 0x018C, 0x8189, 0x0198, 0x819D, 0x8197, 0x0192,
	0x01B0, 0x81B5, 0x81BF, 0x01BA, 0x81AB, 0x01AE, 0x01A4, 0x81A1,
	0x01E0, 0x81E5, 0x81EF, 0x01EA, 0x81FB, 0x01FE, 0x01F4, 0x81F1,
	0x81D3, 0x01D6, 0x01DC, 0x81D9, 0x01C8, 0x81CD, 0x81C7, 0x01C2,
	0x0140, 0x8145, 0x814F, 0x014A, 0x815B, 0x015E, 0x0154, 0x8151,
	0x8173, 0x0176, 0x017C, 0x8179, 0x0168, 0x816D, 0x8167, 0x0162,
	0x8123, 0x0126, 0x012C, 0x8129, 0x0138, 0x813D, 0x8137, 0x0132,
	0x0110, 0x8115, 0x811F, 0x011A, 0x810B, 0x010E, 0x0104, 0x8101,
	0x8303, 0x0306, 0x030C, 0x8309, 0x0318, 0x831D, 0x8317, 0x0312,
	0x0330, 0x8335, 0x833F, 0x033A, 0x832B, 0x032E, 0x0324, 0x8321,
	0x0360, 0x8365, 0x836F, 0x036A, 0x837B, 0x037E, 0x0374, 0x8371,
	0x8353, 0x0356, 0x035C, 0x8359, 0x0348, 0x834D, 0x8347, 0x0342,
	0x03C0, 0x83C5, 0x83CF, 0x03CA, 0x83DB, 0x03DE, 0x03D4, 0x83D1,
	0x83F3, 0x03F6, 0x03FC, 0x83F9, 0x03E8, 0x83ED, 0x83E7, 0x03E2,
	0x83A3, 0x03A6, 0x03AC, 0x83A9, 0x03B8, 0x83BD, 0x83B7, 0x03B2,
	0x0390, 0x8395, 0x839F, 0x039A, 0x838B, 0x038E, 0x0384, 0x8381,
	0x0280, 0x8285, 0x828F, 0x028A, 0x829B, 0x029E, 0x0294, 0x8291,
	0x82B3, 0x02B6, 0x02BC, 0x82B9, 0x02A8, 0x82AD, 0x82A7, 0x02A2,
	0x82E3, 0x02E6, 0x02EC, 0x82E9, 0x02F8, 0x82FD, 0x82F7, 0x02F2,
	0x02D0, 0x82D5, 0x82DF, 0x02DA, 0x82CB, 0x02CE, 0x02C4, 0x82C1,
	0x8243, 0x0246, 0x024C, 0x8249, 0x0258, 0x825D, 0x8257, 0x0252,
	0x0270, 0x8275, 0x827F, 0x027A, 0x826B, 0x026E, 0x0264, 0x8261,
	0x0220, 0x8225, 0x822F, 0x022A, 0x823B, 0x023E, 0x0234, 0x8231,
	0x8213, 0x0216, 0x021C, 0x8219, 0x0208, 0x820D, 0x8207, 0x0202
};

//===计算种子0x8005---计算方程式g(x) = x16+x15+x2+x0
const uint16_t g_crc16_table_ccitt[256] =
{
	0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
	0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
	0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
	0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
	0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
	0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
	0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
	0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
	0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
	0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
	0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
	0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
	0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
	0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
	0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
	0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
	0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
	0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
	0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
	0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
	0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
	0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
	0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
	0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
	0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
	0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
	0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
	0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
	0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
	0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
	0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
	0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

//===计算种子0x3d65---计算方程式g(x) = x16+x15+x2+x0
const uint16_t g_crc16_table_3d65h[256] =
{
	0x0000, 0x365e, 0x6cbc, 0x5ae2, 0xd978, 0xef26, 0xb5c4, 0x839a,
	0xff89, 0xc9d7, 0x9335, 0xa56b, 0x26f1, 0x10af, 0x4a4d, 0x7c13,
	0xb26b, 0x8435, 0xded7, 0xe889, 0x6b13, 0x5d4d, 0x07af, 0x31f1,
	0x4de2, 0x7bbc, 0x215e, 0x1700, 0x949a, 0xa2c4, 0xf826, 0xce78,
	0x29af, 0x1ff1, 0x4513, 0x734d, 0xf0d7, 0xc689, 0x9c6b, 0xaa35,
	0xd626, 0xe078, 0xba9a, 0x8cc4, 0x0f5e, 0x3900, 0x63e2, 0x55bc,
	0x9bc4, 0xad9a, 0xf778, 0xc126, 0x42bc, 0x74e2, 0x2e00, 0x185e,
	0x644d, 0x5213, 0x08f1, 0x3eaf, 0xbd35, 0x8b6b, 0xd189, 0xe7d7,
	0x535e, 0x6500, 0x3fe2, 0x09bc, 0x8a26, 0xbc78, 0xe69a, 0xd0c4,
	0xacd7, 0x9a89, 0xc06b, 0xf635, 0x75af, 0x43f1, 0x1913, 0x2f4d,
	0xe135, 0xd76b, 0x8d89, 0xbbd7, 0x384d, 0x0e13, 0x54f1, 0x62af,
	0x1ebc, 0x28e2, 0x7200, 0x445e, 0xc7c4, 0xf19a, 0xab78, 0x9d26,
	0x7af1, 0x4caf, 0x164d, 0x2013, 0xa389, 0x95d7, 0xcf35, 0xf96b,
	0x8578, 0xb326, 0xe9c4, 0xdf9a, 0x5c00, 0x6a5e, 0x30bc, 0x06e2,
	0xc89a, 0xfec4, 0xa426, 0x9278, 0x11e2, 0x27bc, 0x7d5e, 0x4b00,
	0x3713, 0x014d, 0x5baf, 0x6df1, 0xee6b, 0xd835, 0x82d7, 0xb489,
	0xa6bc, 0x90e2, 0xca00, 0xfc5e, 0x7fc4, 0x499a, 0x1378, 0x2526,
	0x5935, 0x6f6b, 0x3589, 0x03d7, 0x804d, 0xb613, 0xecf1, 0xdaaf,
	0x14d7, 0x2289, 0x786b, 0x4e35, 0xcdaf, 0xfbf1, 0xa113, 0x974d,
	0xeb5e, 0xdd00, 0x87e2, 0xb1bc, 0x3226, 0x0478, 0x5e9a, 0x68c4,
	0x8f13, 0xb94d, 0xe3af, 0xd5f1, 0x566b, 0x6035, 0x3ad7, 0x0c89,
	0x709a, 0x46c4, 0x1c26, 0x2a78, 0xa9e2, 0x9fbc, 0xc55e, 0xf300,
	0x3d78, 0x0b26, 0x51c4, 0x679a, 0xe400, 0xd25e, 0x88bc, 0xbee2,
	0xc2f1, 0xf4af, 0xae4d, 0x9813, 0x1b89, 0x2dd7, 0x7735, 0x416b,
	0xf5e2, 0xc3bc, 0x995e, 0xaf00, 0x2c9a, 0x1ac4, 0x4026, 0x7678,
	0x0a6b, 0x3c35, 0x66d7, 0x5089, 0xd313, 0xe54d, 0xbfaf, 0x89f1,
	0x4789, 0x71d7, 0x2b35, 0x1d6b, 0x9ef1, 0xa8af, 0xf24d, 0xc413,
	0xb800, 0x8e5e, 0xd4bc, 0xe2e2, 0x6178, 0x5726, 0x0dc4, 0x3b9a,
	0xdc4d, 0xea13, 0xb0f1, 0x86af, 0x0535, 0x336b, 0x6989, 0x5fd7,
	0x23c4, 0x159a, 0x4f78, 0x7926, 0xfabc, 0xcce2, 0x9600, 0xa05e,
	0x6e26, 0x5878, 0x029a, 0x34c4, 0xb75e, 0x8100, 0xdbe2, 0xedbc,
	0x91af, 0xa7f1, 0xfd13, 0xcb4d, 0x48d7, 0x7e89, 0x246b, 0x1235,
};

#endif // CRC_USE_CRC16

#ifdef CRC_ENABLE_CRC8
//===CRC8---计算种子0x07---计算方程式 g(x) = x8+x2+x1+1
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
PRO_FLASH_uint8_t  g_crc8_table_07h[256] =
#else
const uint8_t  g_crc8_table_07h[256] =
#endif
{
	0x00,0x07,0x0E,0x09,0x1C,0x1B,0x12,0x15,0x38,0x3F,0x36,0x31,0x24,0x23,0x2A,0x2D,
	0x70,0x77,0x7E,0x79,0x6C,0x6B,0x62,0x65,0x48,0x4F,0x46,0x41,0x54,0x53,0x5A,0x5D,
	0xE0,0xE7,0xEE,0xE9,0xFC,0xFB,0xF2,0xF5,0xD8,0xDF,0xD6,0xD1,0xC4,0xC3,0xCA,0xCD,
	0x90,0x97,0x9E,0x99,0x8C,0x8B,0x82,0x85,0xA8,0xAF,0xA6,0xA1,0xB4,0xB3,0xBA,0xBD,
	0xC7,0xC0,0xC9,0xCE,0xDB,0xDC,0xD5,0xD2,0xFF,0xF8,0xF1,0xF6,0xE3,0xE4,0xED,0xEA,
	0xB7,0xB0,0xB9,0xBE,0xAB,0xAC,0xA5,0xA2,0x8F,0x88,0x81,0x86,0x93,0x94,0x9D,0x9A,
	0x27,0x20,0x29,0x2E,0x3B,0x3C,0x35,0x32,0x1F,0x18,0x11,0x16,0x03,0x04,0x0D,0x0A,
	0x57,0x50,0x59,0x5E,0x4B,0x4C,0x45,0x42,0x6F,0x68,0x61,0x66,0x73,0x74,0x7D,0x7A,
	0x89,0x8E,0x87,0x80,0x95,0x92,0x9B,0x9C,0xB1,0xB6,0xBF,0xB8,0xAD,0xAA,0xA3,0xA4,
	0xF9,0xFE,0xF7,0xF0,0xE5,0xE2,0xEB,0xEC,0xC1,0xC6,0xCF,0xC8,0xDD,0xDA,0xD3,0xD4,
	0x69,0x6E,0x67,0x60,0x75,0x72,0x7B,0x7C,0x51,0x56,0x5F,0x58,0x4D,0x4A,0x43,0x44,
	0x19,0x1E,0x17,0x10,0x05,0x02,0x0B,0x0C,0x21,0x26,0x2F,0x28,0x3D,0x3A,0x33,0x34,
	0x4E,0x49,0x40,0x47,0x52,0x55,0x5C,0x5B,0x76,0x71,0x78,0x7F,0x6A,0x6D,0x64,0x63,
	0x3E,0x39,0x30,0x37,0x22,0x25,0x2C,0x2B,0x06,0x01,0x08,0x0F,0x1A,0x1D,0x14,0x13,
	0xAE,0xA9,0xA0,0xA7,0xB2,0xB5,0xBC,0xBB,0x96,0x91,0x98,0x9F,0x8A,0x8D,0x84,0x83,
	0xDE,0xD9,0xD0,0xD7,0xC2,0xC5,0xCC,0xCB,0xE6,0xE1,0xE8,0xEF,0xFA,0xFD,0xF4,0xF3
};

//===CRC8---计算种子0x31---计算方程式 g(x) = x8+x5+x4+1
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
PRO_FLASH_uint8_t  g_crc8_table_31h[256] =
#else
const uint8_t  g_crc8_table_31h[256] =
#endif
{
	0x00,0x31,0x62,0x53,0xc4,0xf5,0xa6,0x97,0xb9,0x88,0xdb,0xea,0x7d,0x4c,0x1f,0x2e,
	0x43,0x72,0x21,0x10,0x87,0xb6,0xe5,0xd4,0xfa,0xcb,0x98,0xa9,0x3e,0x0f,0x5c,0x6d,
	0x86,0xb7,0xe4,0xd5,0x42,0x73,0x20,0x11,0x3f,0x0e,0x5d,0x6c,0xfb,0xca,0x99,0xa8,
	0xc5,0xf4,0xa7,0x96,0x01,0x30,0x63,0x52,0x7c,0x4d,0x1e,0x2f,0xb8,0x89,0xda,0xeb,
	0x3d,0x0c,0x5f,0x6e,0xf9,0xc8,0x9b,0xaa,0x84,0xb5,0xe6,0xd7,0x40,0x71,0x22,0x13,
	0x7e,0x4f,0x1c,0x2d,0xba,0x8b,0xd8,0xe9,0xc7,0xf6,0xa5,0x94,0x03,0x32,0x61,0x50,
	0xbb,0x8a,0xd9,0xe8,0x7f,0x4e,0x1d,0x2c,0x02,0x33,0x60,0x51,0xc6,0xf7,0xa4,0x95,
	0xf8,0xc9,0x9a,0xab,0x3c,0x0d,0x5e,0x6f,0x41,0x70,0x23,0x12,0x85,0xb4,0xe7,0xd6,
	0x7a,0x4b,0x18,0x29,0xbe,0x8f,0xdc,0xed,0xc3,0xf2,0xa1,0x90,0x07,0x36,0x65,0x54,
	0x39,0x08,0x5b,0x6a,0xfd,0xcc,0x9f,0xae,0x80,0xb1,0xe2,0xd3,0x44,0x75,0x26,0x17,
	0xfc,0xcd,0x9e,0xaf,0x38,0x09,0x5a,0x6b,0x45,0x74,0x27,0x16,0x81,0xb0,0xe3,0xd2,
	0xbf,0x8e,0xdd,0xec,0x7b,0x4a,0x19,0x28,0x06,0x37,0x64,0x55,0xc2,0xf3,0xa0,0x91,
	0x47,0x76,0x25,0x14,0x83,0xb2,0xe1,0xd0,0xfe,0xcf,0x9c,0xad,0x3a,0x0b,0x58,0x69,
 	0xc1,0xf0,0xa3,0x92,0x05,0x34,0x67,0x56,0x78,0x49,0x1a,0x2b,0xbc,0x8d,0xde,0xef,
	0x82,0xb3,0xe0,0xd1,0x46,0x77,0x24,0x15,0x3b,0x0a,0x59,0x68,0xff,0xce,0x9d,0xac
};
//===CRC8---计算种子0x31---计算方程式 x8+x6+x4+x3+x2+x1
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
PRO_FLASH_uint8_t  g_crc8_table_5eh[256] =
#else
const uint8_t  g_crc8_table_5eh[256] =
#endif
{
	0x00,0x5e,0xbc,0xe2,0x61,0x3f,0xdd,0x83,0xc2,0x9c,0x7e,0x20,0xa3,0xfd,0x1f,0x41,
	0x9d,0xc3,0x21,0x7f,0xfc,0xa2,0x40,0x1e,0x5f,0x01,0xe3,0xbd,0x3e,0x60,0x82,0xdc,
	0x23,0x7d,0x9f,0xc1,0x42,0x1c,0xfe,0xa0,0xe1,0xbf,0x5d,0x03,0x80,0xde,0x3c,0x62,
	0xbe,0xe0,0x02,0x5c,0xdf,0x81,0x63,0x3d,0x7c,0x22,0xc0,0x9e,0x1d,0x43,0xa1,0xff,
	0x46,0x18,0xfa,0xa4,0x27,0x79,0x9b,0xc5,0x84,0xda,0x38,0x66,0xe5,0xbb,0x59,0x07,
	0xdb,0x85,0x67,0x39,0xba,0xe4,0x06,0x58,0x19,0x47,0xa5,0xfb,0x78,0x26,0xc4,0x9a,
	0x65,0x3b,0xd9,0x87,0x04,0x5a,0xb8,0xe6,0xa7,0xf9,0x1b,0x45,0xc6,0x98,0x7a,0x24,
	0xf8,0xa6,0x44,0x1a,0x99,0xc7,0x25,0x7b,0x3a,0x64,0x86,0xd8,0x5b,0x05,0xe7,0xb9,
	0x8c,0xd2,0x30,0x6e,0xed,0xb3,0x51,0x0f,0x4e,0x10,0xf2,0xac,0x2f,0x71,0x93,0xcd,
	0x11,0x4f,0xad,0xf3,0x70,0x2e,0xcc,0x92,0xd3,0x8d,0x6f,0x31,0xb2,0xec,0x0e,0x50,
	0xaf,0xf1,0x13,0x4d,0xce,0x90,0x72,0x2c,0x6d,0x33,0xd1,0x8f,0x0c,0x52,0xb0,0xee,
	0x32,0x6c,0x8e,0xd0,0x53,0x0d,0xef,0xb1,0xf0,0xae,0x4c,0x12,0x91,0xcf,0x2d,0x73,
	0xca,0x94,0x76,0x28,0xab,0xf5,0x17,0x49,0x08,0x56,0xb4,0xea,0x69,0x37,0xd5,0x8b,
	0x57,0x09,0xeb,0xb5,0x36,0x68,0x8a,0xd4,0x95,0xcb,0x29,0x77,0xf4,0xaa,0x48,0x16,
	0xe9,0xb7,0x55,0x0b,0x88,0xd6,0x34,0x6a,0x2b,0x75,0x97,0xc9,0x4a,0x14,0xf6,0xa8,
	0x74,0x2a,0xc8,0x96,0x15,0x4b,0xa9,0xf7,0xb6,0xe8,0x0a,0x54,0xd7,0x89,0x6b,0x35
};
//===计算种子0x9B---计算方程式 g(x) = x8+x6+x4+x3+x2+x1
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
PRO_FLASH_uint8_t  g_crc8_table_9bh[256] =
#else
const uint8_t  g_crc8_table_9bh[256] =
#endif  
{
	0x00, 0x9B, 0xAD, 0x36, 0xC1, 0x5A, 0x6C, 0xF7,	0x19, 0x82, 0xB4, 0x2F, 0xD8, 0x43, 0x75, 0xEE,
	0x32, 0xA9, 0x9F, 0x04, 0xF3, 0x68, 0x5E, 0xC5,	0x2B, 0xB0, 0x86, 0x1D, 0xEA, 0x71, 0x47, 0xDC,
	0x64, 0xFF, 0xC9, 0x52, 0xA5, 0x3E, 0x08, 0x93,	0x7D, 0xE6, 0xD0, 0x4B, 0xBC, 0x27, 0x11, 0x8A,
	0x56, 0xCD, 0xFB, 0x60, 0x97, 0x0C, 0x3A, 0xA1,	0x4F, 0xD4, 0xE2, 0x79, 0x8E, 0x15, 0x23, 0xB8,
	0xC8, 0x53, 0x65, 0xFE, 0x09, 0x92, 0xA4, 0x3F,	0xD1, 0x4A, 0x7C, 0xE7, 0x10, 0x8B, 0xBD, 0x26,
	0xFA, 0x61, 0x57, 0xCC, 0x3B, 0xA0, 0x96, 0x0D,	0xE3, 0x78, 0x4E, 0xD5, 0x22, 0xB9, 0x8F, 0x14,
	0xAC, 0x37, 0x01, 0x9A, 0x6D, 0xF6, 0xC0, 0x5B,	0xB5, 0x2E, 0x18, 0x83, 0x74, 0xEF, 0xD9, 0x42,
	0x9E, 0x05, 0x33, 0xA8, 0x5F, 0xC4, 0xF2, 0x69,	0x87, 0x1C, 0x2A, 0xB1, 0x46, 0xDD, 0xEB, 0x70,
	0x0B, 0x90, 0xA6, 0x3D, 0xCA, 0x51, 0x67, 0xFC,	0x12, 0x89, 0xBF, 0x24, 0xD3, 0x48, 0x7E, 0xE5,
	0x39, 0xA2, 0x94, 0x0F, 0xF8, 0x63, 0x55, 0xCE,	0x20, 0xBB, 0x8D, 0x16, 0xE1, 0x7A, 0x4C, 0xD7,
	0x6F, 0xF4, 0xC2, 0x59, 0xAE, 0x35, 0x03, 0x98,	0x76, 0xED, 0xDB, 0x40, 0xB7, 0x2C, 0x1A, 0x81,
	0x5D, 0xC6, 0xF0, 0x6B, 0x9C, 0x07, 0x31, 0xAA,	0x44, 0xDF, 0xE9, 0x72, 0x85, 0x1E, 0x28, 0xB3,
	0xC3, 0x58, 0x6E, 0xF5, 0x02, 0x99, 0xAF, 0x34,	0xDA, 0x41, 0x77, 0xEC, 0x1B, 0x80, 0xB6, 0x2D,
	0xF1, 0x6A, 0x5C, 0xC7, 0x30, 0xAB, 0x9D, 0x06,	0xE8, 0x73, 0x45, 0xDE, 0x29, 0xB2, 0x84, 0x1F,
	0xA7, 0x3C, 0x0A, 0x91, 0x66, 0xFD, 0xCB, 0x50,	0xBE, 0x25, 0x13, 0x88, 0x7F, 0xE4, 0xD2, 0x49,
	0x95, 0x0E, 0x38, 0xA3, 0x54, 0xCF, 0xF9, 0x62,	0x8C, 0x17, 0x21, 0xBA, 0x4D, 0xD6, 0xE0, 0x7B
};

///===计算种子0x39-- - 计算方程式 g(x) = x8 + x6 + x4 + x3 + x2 + x1
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
PRO_FLASH_uint8_t  g_crc8_table_39h[256] =
#else
const uint8_t  g_crc8_table_39h[256] =
#endif 
{
	0x00, 0x39, 0x72, 0x4B, 0xE4, 0xDD, 0x96, 0xAF,	0xF1, 0xC8, 0x83, 0xBA, 0x15, 0x2C, 0x67, 0x5E,
	0xDB, 0xE2, 0xA9, 0x90, 0x3F, 0x06, 0x4D, 0x74,	0x2A, 0x13, 0x58, 0x61, 0xCE, 0xF7, 0xBC, 0x85,
	0x8F, 0xB6, 0xFD, 0xC4, 0x6B, 0x52, 0x19, 0x20,	0x7E, 0x47, 0x0C, 0x35, 0x9A, 0xA3, 0xE8, 0xD1,
	0x54, 0x6D, 0x26, 0x1F, 0xB0, 0x89, 0xC2, 0xFB,	0xA5, 0x9C, 0xD7, 0xEE, 0x41, 0x78, 0x33, 0x0A,
	0x27, 0x1E, 0x55, 0x6C, 0xC3, 0xFA, 0xB1, 0x88,	0xD6, 0xEF, 0xA4, 0x9D, 0x32, 0x0B, 0x40, 0x79,
	0xFC, 0xC5, 0x8E, 0xB7, 0x18, 0x21, 0x6A, 0x53,	0x0D, 0x34, 0x7F, 0x46, 0xE9, 0xD0, 0x9B, 0xA2,
	0xA8, 0x91, 0xDA, 0xE3, 0x4C, 0x75, 0x3E, 0x07,	0x59, 0x60, 0x2B, 0x12, 0xBD, 0x84, 0xCF, 0xF6,
	0x73, 0x4A, 0x01, 0x38, 0x97, 0xAE, 0xE5, 0xDC,	0x82, 0xBB, 0xF0, 0xC9, 0x66, 0x5F, 0x14, 0x2D,
	0x4E, 0x77, 0x3C, 0x05, 0xAA, 0x93, 0xD8, 0xE1,	0xBF, 0x86, 0xCD, 0xF4, 0x5B, 0x62, 0x29, 0x10,
	0x95, 0xAC, 0xE7, 0xDE, 0x71, 0x48, 0x03, 0x3A,	0x64, 0x5D, 0x16, 0x2F, 0x80, 0xB9, 0xF2, 0xCB,
	0xC1, 0xF8, 0xB3, 0x8A, 0x25, 0x1C, 0x57, 0x6E,	0x30, 0x09, 0x42, 0x7B, 0xD4, 0xED, 0xA6, 0x9F,
	0x1A, 0x23, 0x68, 0x51, 0xFE, 0xC7, 0x8C, 0xB5,	0xEB, 0xD2, 0x99, 0xA0, 0x0F, 0x36, 0x7D, 0x44,
	0x69, 0x50, 0x1B, 0x22, 0x8D, 0xB4, 0xFF, 0xC6,	0x98, 0xA1, 0xEA, 0xD3, 0x7C, 0x45, 0x0E, 0x37,
	0xB2, 0x8B, 0xC0, 0xF9, 0x56, 0x6F, 0x24, 0x1D,	0x43, 0x7A, 0x31, 0x08, 0xA7, 0x9E, 0xD5, 0xEC,
	0xE6, 0xDF, 0x94, 0xAD, 0x02, 0x3B, 0x70, 0x49,	0x17, 0x2E, 0x65, 0x5C, 0xF3, 0xCA, 0x81, 0xB8,
	0x3D, 0x04, 0x4F, 0x76, 0xD9, 0xE0, 0xAB, 0x92,	0xCC, 0xF5, 0xBE, 0x87, 0x28, 0x11, 0x5A, 0x63
};

//===计算种子0xD5-- - 计算方程式 g(x) = x8 + x6 + x4 + x3 + x2 + x1
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
PRO_FLASH_uint8_t  g_crc8_table_d5h[256] =
#else
const uint8_t  g_crc8_table_d5h[256] =
#endif 
{
	0x00, 0xD5, 0x7F, 0xAA, 0xFE, 0x2B, 0x81, 0x54,	0x29, 0xFC, 0x56, 0x83, 0xD7, 0x02, 0xA8, 0x7D,
	0x52, 0x87, 0x2D, 0xF8, 0xAC, 0x79, 0xD3, 0x06,	0x7B, 0xAE, 0x04, 0xD1, 0x85, 0x50, 0xFA, 0x2F,
	0xA4, 0x71, 0xDB, 0x0E, 0x5A, 0x8F, 0x25, 0xF0,	0x8D, 0x58, 0xF2, 0x27, 0x73, 0xA6, 0x0C, 0xD9,
	0xF6, 0x23, 0x89, 0x5C, 0x08, 0xDD, 0x77, 0xA2,	0xDF, 0x0A, 0xA0, 0x75, 0x21, 0xF4, 0x5E, 0x8B,
	0x9D, 0x48, 0xE2, 0x37, 0x63, 0xB6, 0x1C, 0xC9,	0xB4, 0x61, 0xCB, 0x1E, 0x4A, 0x9F, 0x35, 0xE0,
	0xCF, 0x1A, 0xB0, 0x65, 0x31, 0xE4, 0x4E, 0x9B,	0xE6, 0x33, 0x99, 0x4C, 0x18, 0xCD, 0x67, 0xB2,
	0x39, 0xEC, 0x46, 0x93, 0xC7, 0x12, 0xB8, 0x6D,	0x10, 0xC5, 0x6F, 0xBA, 0xEE, 0x3B, 0x91, 0x44,
	0x6B, 0xBE, 0x14, 0xC1, 0x95, 0x40, 0xEA, 0x3F,	0x42, 0x97, 0x3D, 0xE8, 0xBC, 0x69, 0xC3, 0x16,
	0xEF, 0x3A, 0x90, 0x45, 0x11, 0xC4, 0x6E, 0xBB,	0xC6, 0x13, 0xB9, 0x6C, 0x38, 0xED, 0x47, 0x92,
	0xBD, 0x68, 0xC2, 0x17, 0x43, 0x96, 0x3C, 0xE9,	0x94, 0x41, 0xEB, 0x3E, 0x6A, 0xBF, 0x15, 0xC0,
	0x4B, 0x9E, 0x34, 0xE1, 0xB5, 0x60, 0xCA, 0x1F,	0x62, 0xB7, 0x1D, 0xC8, 0x9C, 0x49, 0xE3, 0x36,
	0x19, 0xCC, 0x66, 0xB3, 0xE7, 0x32, 0x98, 0x4D,	0x30, 0xE5, 0x4F, 0x9A, 0xCE, 0x1B, 0xB1, 0x64,
	0x72, 0xA7, 0x0D, 0xD8, 0x8C, 0x59, 0xF3, 0x26,	0x5B, 0x8E, 0x24, 0xF1, 0xA5, 0x70, 0xDA, 0x0F,
	0x20, 0xF5, 0x5F, 0x8A, 0xDE, 0x0B, 0xA1, 0x74,	0x09, 0xDC, 0x76, 0xA3, 0xF7, 0x22, 0x88, 0x5D,
	0xD6, 0x03, 0xA9, 0x7C, 0x28, 0xFD, 0x57, 0x82,	0xFF, 0x2A, 0x80, 0x55, 0x01, 0xD4, 0x7E, 0xAB,
	0x84, 0x51, 0xFB, 0x2E, 0x7A, 0xAF, 0x05, 0xD0,	0xAD, 0x78, 0xD2, 0x07, 0x53, 0x86, 0x2C, 0xF9

};

//===计算种子0x1D---计算方程式 g(x) = x8+x6+x4+x3+x2+x1
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
PRO_FLASH_uint8_t  g_crc8_table_1dh[256] =
#else
const uint8_t  g_crc8_table_1dh[256] =
#endif 
{
	0x00, 0x1D, 0x3A, 0x27, 0x74, 0x69, 0x4E, 0x53,	0xE8, 0xF5, 0xD2, 0xCF, 0x9C, 0x81, 0xA6, 0xBB,
	0xCD, 0xD0, 0xF7, 0xEA, 0xB9, 0xA4, 0x83, 0x9E,	0x25, 0x38, 0x1F, 0x02, 0x51, 0x4C, 0x6B, 0x76,
	0x87, 0x9A, 0xBD, 0xA0, 0xF3, 0xEE, 0xC9, 0xD4,	0x6F, 0x72, 0x55, 0x48, 0x1B, 0x06, 0x21, 0x3C,
	0x4A, 0x57, 0x70, 0x6D, 0x3E, 0x23, 0x04, 0x19,	0xA2, 0xBF, 0x98, 0x85, 0xD6, 0xCB, 0xEC, 0xF1,
	0x13, 0x0E, 0x29, 0x34, 0x67, 0x7A, 0x5D, 0x40,	0xFB, 0xE6, 0xC1, 0xDC, 0x8F, 0x92, 0xB5, 0xA8,
	0xDE, 0xC3, 0xE4, 0xF9, 0xAA, 0xB7, 0x90, 0x8D,	0x36, 0x2B, 0x0C, 0x11, 0x42, 0x5F, 0x78, 0x65,
	0x94, 0x89, 0xAE, 0xB3, 0xE0, 0xFD, 0xDA, 0xC7,	0x7C, 0x61, 0x46, 0x5B, 0x08, 0x15, 0x32, 0x2F,
	0x59, 0x44, 0x63, 0x7E, 0x2D, 0x30, 0x17, 0x0A,	0xB1, 0xAC, 0x8B, 0x96, 0xC5, 0xD8, 0xFF, 0xE2,
	0x26, 0x3B, 0x1C, 0x01, 0x52, 0x4F, 0x68, 0x75,	0xCE, 0xD3, 0xF4, 0xE9, 0xBA, 0xA7, 0x80, 0x9D,
	0xEB, 0xF6, 0xD1, 0xCC, 0x9F, 0x82, 0xA5, 0xB8,	0x03, 0x1E, 0x39, 0x24, 0x77, 0x6A, 0x4D, 0x50,
	0xA1, 0xBC, 0x9B, 0x86, 0xD5, 0xC8, 0xEF, 0xF2,	0x49, 0x54, 0x73, 0x6E, 0x3D, 0x20, 0x07, 0x1A,
	0x6C, 0x71, 0x56, 0x4B, 0x18, 0x05, 0x22, 0x3F,	0x84, 0x99, 0xBE, 0xA3, 0xF0, 0xED, 0xCA, 0xD7,
	0x35, 0x28, 0x0F, 0x12, 0x41, 0x5C, 0x7B, 0x66,	0xDD, 0xC0, 0xE7, 0xFA, 0xA9, 0xB4, 0x93, 0x8E,
	0xF8, 0xE5, 0xC2, 0xDF, 0x8C, 0x91, 0xB6, 0xAB,	0x10, 0x0D, 0x2A, 0x37, 0x64, 0x79, 0x5E, 0x43,
	0xB2, 0xAF, 0x88, 0x95, 0xC6, 0xDB, 0xFC, 0xE1, 0x5A, 0x47, 0x60, 0x7D, 0x2E, 0x33, 0x14, 0x09,
	0x7F, 0x62, 0x45, 0x58, 0x0B, 0x16, 0x31, 0x2C,	0x97, 0x8A, 0xAD, 0xB0, 0xE3, 0xFE, 0xD9, 0xC4
};

//===计算种子0x2F---计算方程式 g(x) = x8+x6+x4+x3+x2+x1
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
PRO_FLASH_uint8_t  g_crc8_table_2fh[256] =
#else
const uint8_t  g_crc8_table_2fh[256] =
#endif
{
	0x00, 0x2F, 0x5E, 0x71, 0xBC, 0x93, 0xE2, 0xCD,	0x57, 0x78, 0x09, 0x26, 0xEB, 0xC4, 0xB5, 0x9A,
	0xAE, 0x81, 0xF0, 0xDF, 0x12, 0x3D, 0x4C, 0x63,	0xF9, 0xD6, 0xA7, 0x88, 0x45, 0x6A, 0x1B, 0x34,
	0x73, 0x5C, 0x2D, 0x02, 0xCF, 0xE0, 0x91, 0xBE,	0x24, 0x0B, 0x7A, 0x55, 0x98, 0xB7, 0xC6, 0xE9,
	0xDD, 0xF2, 0x83, 0xAC, 0x61, 0x4E, 0x3F, 0x10, 0x8A, 0xA5, 0xD4, 0xFB, 0x36, 0x19, 0x68, 0x47,
	0xE6, 0xC9, 0xB8, 0x97, 0x5A, 0x75, 0x04, 0x2B,	0xB1, 0x9E, 0xEF, 0xC0, 0x0D, 0x22, 0x53, 0x7C,
	0x48, 0x67, 0x16, 0x39, 0xF4, 0xDB, 0xAA, 0x85,	0x1F, 0x30, 0x41, 0x6E, 0xA3, 0x8C, 0xFD, 0xD2,
	0x95, 0xBA, 0xCB, 0xE4, 0x29, 0x06, 0x77, 0x58,	0xC2, 0xED, 0x9C, 0xB3, 0x7E, 0x51, 0x20, 0x0F,
	0x3B, 0x14, 0x65, 0x4A, 0x87, 0xA8, 0xD9, 0xF6,	0x6C, 0x43, 0x32, 0x1D, 0xD0, 0xFF, 0x8E, 0xA1,
	0xE3, 0xCC, 0xBD, 0x92, 0x5F, 0x70, 0x01, 0x2E,	0xB4, 0x9B, 0xEA, 0xC5, 0x08, 0x27, 0x56, 0x79,
	0x4D, 0x62, 0x13, 0x3C, 0xF1, 0xDE, 0xAF, 0x80,	0x1A, 0x35, 0x44, 0x6B, 0xA6, 0x89, 0xF8, 0xD7,
	0x90, 0xBF, 0xCE, 0xE1, 0x2C, 0x03, 0x72, 0x5D,	0xC7, 0xE8, 0x99, 0xB6, 0x7B, 0x54, 0x25, 0x0A,
	0x3E, 0x11, 0x60, 0x4F, 0x82, 0xAD, 0xDC, 0xF3,	0x69, 0x46, 0x37, 0x18, 0xD5, 0xFA, 0x8B, 0xA4,
	0x05, 0x2A, 0x5B, 0x74, 0xB9, 0x96, 0xE7, 0xC8,	0x52, 0x7D, 0x0C, 0x23, 0xEE, 0xC1, 0xB0, 0x9F,
	0xAB, 0x84, 0xF5, 0xDA, 0x17, 0x38, 0x49, 0x66,	0xFC, 0xD3, 0xA2, 0x8D, 0x40, 0x6F, 0x1E, 0x31,
	0x76, 0x59, 0x28, 0x07, 0xCA, 0xE5, 0x94, 0xBB,	0x21, 0x0E, 0x7F, 0x50, 0x9D, 0xB2, 0xC3, 0xEC,
	0xD8, 0xF7, 0x86, 0xA9, 0x64, 0x4B, 0x3A, 0x15,	0x8F, 0xA0, 0xD1, 0xFE, 0x33, 0x1C, 0x6D, 0x42
};

#endif // CRC_USE_CRC8

//===全局变量定义
vltuint8_t g_crc_enable = ERROR_1;																						//---0--使能，0---使能

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
void crc_time_tick_init(uint32_t(*func_time_tick)(void))
{
	//---注册节拍函数，如果没有节拍函数，默认使用系统滴答作为节拍
	(func_time_tick != NULL) ?
		(crc_time_tick = func_time_tick) :
		(crc_time_tick = sys_tick_task_get_tick);
	//---校验节拍函数
	if (crc_time_tick == NULL)
	{
		crc_time_tick = sys_tick_task_get_tick;
	}
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参数:
//////输出参数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
void crc_init(uint32_t(*func_time_tick)(void))
{
	crc_deinit();
#if defined(CRC)&&defined(CRC_ENABLE_CRC32_HW)
	//---使能CRC模块的总线时钟
	LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_CRC);
#endif
#if defined(CRC_ENABLE_CHECK_SUM)||\
	defined(CRC_ENABLE_CRC8)||\
	defined(CRC_ENABLE_CRC16)||\
	defined(CRC_ENABLE_CRC32)
	g_crc_enable = OK_0;
#endif
	//---注册节拍函数，如果没有节拍函数，默认使用系统滴答作为节拍
	(func_time_tick != NULL) ?
		(crc_time_tick = func_time_tick) :
		(crc_time_tick = sys_tick_task_get_tick);
	//---校验节拍函数
	if (crc_time_tick==NULL)
	{
		crc_time_tick = sys_tick_task_get_tick;
	}
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参数:
//////输出参数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
void crc_deinit(void)
{
#if defined(CRC)&&defined(CRC_ENABLE_CRC32_HW)
	LL_CRC_DeInit(CRC);
#endif
	g_crc_enable = ERROR_1;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参数:
//////输出参数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t crc_enable(void)
{
	return g_crc_enable;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参数:
//////输出参数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
void crc_crc32_hw_reset(void)
{
#if defined(CRC)&&defined(CRC_ENABLE_CRC32_HW)
	//---复位CRC
	LL_CRC_ResetCRCCalculationUnit(CRC);
#endif
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参数:
//////输出参数:
//////说		明: 使用硬件单元计算的CRC的值
//////////////////////////////////////////////////////////////////////////////
uint32_t crc_crc32_hw_crc(uint8_t *buffer, uint32_t length)
{
#if defined(CRC)&&defined(CRC_ENABLE_CRC32_HW)
	uint32_t index = 0, nTemp = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---复位CRC模块
	crc_crc32_hw_reset();
	//---计算CRC值
	for (index = 0; index < length; index++)
	{
		//---强制转换为4字节数据
		nTemp = buffer[index];
		//---计算CRC
		LL_CRC_FeedData32(CRC, nTemp);
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(),cnt)> CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	//---返回计算结果
	return LL_CRC_ReadData32(CRC);
#else
	return 0;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参数:
//////输出参数:
//////说		明: 查表实现的CRC16算法
//////////////////////////////////////////////////////////////////////////////
uint32_t crc_crc32_table(uint8_t *buffer, uint32_t length)
{
#ifdef CRC_ENABLE_CRC32
	uint32_t nReg = 0xFFFFFFFF, nTemp = 0, nIndex = 0, tIndex = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---开始计算CRC32的值
	for (tIndex = 0; tIndex < length; tIndex++)
	{
		nReg ^= buffer[tIndex];
		//---4字节数据计算
		for (nIndex = 0; nIndex < 4; nIndex++)
		{
			//---取一个字节，查表
			nTemp = g_crc32_table_mpeg_2[((nReg >> 24) & 0xFF)];
			//---丢掉计算过的头一个BYTE
			nReg <<= 8;
			//---与前一个BYTE的计算结果异或
			nReg ^= nTemp;
			//---校验是否超时
			if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
			{
				//---更新时间标签
				cnt = crc_time_tick();
				//---喂狗
				WDT_RESET();
			}
		}
	}
	return nReg;
#else
	return 0;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参数:
//////输出参数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint32_t crc_crc32_crc(uint8_t *buffer, uint32_t length)
{
#if defined(CRC)&&defined(CRC_ENABLE_CRC32_HW)
	return crc_crc32_hw_crc(buffer, length);
#elif defined(CRC_ENABLE_CRC32)
	return crc_crc32_table(buffer, length);
#else
	return 0
#endif  
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint32_t crc_crc32_mpeg_2(uint8_t* buffer, uint32_t length)
{
	uint32_t i = 0;
	uint32_t crc = 0xFFFFFFFF;
	uint32_t nreg = 0;
	uint32_t index = 0;
	for (index = 0; index < length; index++)
	{
		nreg = buffer[index];
		crc ^= nreg << 24;
		for (i = 0; i < 8; ++i)
		{
			if ((crc & 0x80000000) != 0)
			{
				crc = (crc << 1) ^ 0x04C11DB7;
			}
			else
			{
				crc <<= 1;
			}
		}
	}
	return crc;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint32_t crc_crc32_table_mpeg_2(uint8_t* buffer, uint32_t length)
{
	uint32_t index = 0;
	uint32_t crc = 0xFFFFFFFF;
	uint8_t wChar = 0;
	for (index = 0; index < length; index++)
	{
		wChar = (uint8_t)((crc >> 24) ^ buffer[index]);
		crc = (crc << 8) ^ g_crc32_table_mpeg_2[wChar];
	}
	return crc;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint32_t crc_crc32_iso_hdlc(uint8_t* buffer, uint32_t length)
{
	uint32_t i = 0;
	uint32_t crc = 0xFFFFFFFF;
	uint32_t index = 0;
	for (index = 0; index < length; index++)
	{
		crc ^= buffer[index];
		for (i = 0; i < 8; ++i)
		{
			if ((crc & 0x00000001) != 0)
			{
				crc = (crc >> 1) ^ 0xEDB88320;
			}
			else
			{
				crc = (crc >> 1);
			}
		}
	}
	return crc ^ 0xFFFFFFFF;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint32_t crc_crc32_table_iso_hdlc(uint8_t* buffer, uint32_t length)
{
	uint32_t index = 0;
	uint32_t crc = 0xFFFFFFFF;
	uint8_t wChar = 0;
	for (index = 0; index < length; index++)
	{
		wChar = (uint8_t)(crc ^ buffer[index]);
		crc = (crc >> 8) ^ g_crc32_table_iso_hdlc[wChar];
	}
	return crc ^ 0xFFFFFFFF;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint32_t crc_crc32_table_stm32(uint8_t* buffer, uint32_t length)
{
	uint32_t nReg = 0xFFFFFFFF;
	uint32_t nTemp = 0;
	uint32_t nIndex = 0;
	uint32_t tIndex = 0;
	//---开始计算CRC32的值
	for (tIndex = 0; tIndex < length; tIndex++)
	{
		nReg ^= buffer[tIndex];
		//---4字节数据计算
		for (nIndex = 0; nIndex < 4; nIndex++)
		{
			//---取一个字节，查表
			nTemp = g_crc32_table_mpeg_2[((nReg >> 24) & 0xFF)];
			//---丢掉计算过的头一个BYTE
			nReg <<= 8;
			//---与前一个BYTE的计算结果异或
			nReg ^= nTemp;
		}
	}
	return nReg;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint32_t crc_crc32_type(uint16_t type,uint8_t* buffer, uint32_t length)
{
	uint32_t _return = 0;
	switch (type)
	{
		case CRC32_TYPE_NONE:
		{
			_return = 0;
			break;
		}
#ifdef CRC32_ENABLE_MPEG_2
		case CRC32_TYPE_MPEG_2:
		{
			_return = crc_crc32_mpeg_2(buffer, length);
			break;
		}
		case CRC32_TYPE_TABLE_MPEG_2:
		{
			_return = crc_crc32_table_mpeg_2(buffer, length);
			break;
		}
#endif
#ifdef CRC32_ENABLE_ISO_HDLC
		case CRC32_TYPE_ISO_HDLC:
		{
			_return = crc_crc32_iso_hdlc(buffer, length);
			break;
		}
		case CRC32_TYPE_TABLE_ISO_HDLC:
		{
			_return = crc_crc32_table_iso_hdlc(buffer, length);
			break;
		}
#endif
#ifdef CRC32_ENABLE_STM32
		case CRC32_TYPE_STM32:
		{
			_return = crc_crc32_table_stm32(buffer,length);
			break;
		}
		case CRC32_TYPE_TABLE_STM32:
		{
			_return = crc_crc32_crc(buffer, length);
			break;
		}
#endif
		default:
		{
			_return = 0;
			break;
		}
	}
	return  _return;
}


///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参数:
//////输出参数:
//////说		明: 8位校验和--- X^8 + X^2 + X^1 + 1
//////////////////////////////////////////////////////////////////////////////
uint8_t crc_crc8_table(uint8_t crcSeed,uint8_t crc, uint8_t *buffer, uint32_t length)
{
#ifdef CRC_ENABLE_CRC8
	uint8_t nTableIndex;
	uint8_t nReg = crc;
	uint32_t index = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	for (index = 0; index < length; index++)
	{
		nTableIndex = nReg ^ buffer[index];
		//---选择合适的CRC8表
		switch (crcSeed)
		{
			case CRC8_TABLE_07H:
			{
				//---为了减少AVR芯片SRM的占用
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
				nReg = PGM_data_read_BYTE(g_crc8_table_07h + nTableIndex);
#else
				nReg = g_crc8_table_07h[nTableIndex];
#endif
				break;
			}
			case CRC8_TABLE_31H:
			{
				//---为了减少AVR芯片SRM的占用
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
				nReg = PGM_data_read_BYTE(g_crc8_table_31h + nTableIndex);
#else
				nReg = g_crc8_table_31h[nTableIndex];
#endif
				break;
			}
			case CRC8_TABLE_5EH:
			{
				//---为了减少AVR芯片SRM的占用
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
				nReg = PGM_data_read_BYTE(g_crc8_table_5eh + nTableIndex);
#else
				nReg = g_crc8_table_5eh[nTableIndex];
#endif
			case CRC8_TABLE_9BH:
			{
				//---为了减少AVR芯片SRM的占用
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
				nReg = PGM_data_read_BYTE(g_crc8_table_9bh + nTableIndex);
#else
				nReg = g_crc8_table_9bh[nTableIndex];
#endif
				break;
			}
			case CRC8_TABLE_39H:
			{
				//---为了减少AVR芯片SRM的占用
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
				nReg = PGM_data_read_BYTE(g_crc8_table_39h + nTableIndex);
#else
				nReg = g_crc8_table_39h[nTableIndex];
#endif
				break;
			}
			case CRC8_TABLE_D5H:
			{
				//---为了减少AVR芯片SRM的占用
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
				nReg = PGM_data_read_BYTE(g_crc8_table_d5h + nTableIndex);
#else
				nReg = g_crc8_table_d5h[nTableIndex];
#endif
				break;
			}
			case CRC8_TABLE_1DH:
			{
				//---为了减少AVR芯片SRM的占用
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
				nReg = PGM_data_read_BYTE(g_crc8_table_1dh + nTableIndex);
#else
				nReg = g_crc8_table_1dh[nTableIndex];
#endif
				break;
			}
			case CRC8_TABLE_2FH:
			{
				//---为了减少AVR芯片SRM的占用
#if defined(MCU_USE_AVR)&&!defined(CRC_USE_SRAM)
				nReg = PGM_data_read_BYTE(g_crc8_table_2fh + nTableIndex);
#else
				nReg = g_crc8_table_2fh[nTableIndex];
#endif
				break;
			}
			default:
				break;
			}
		}
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return nReg;
#else
	return 0;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint8_t crc_crc8_type(uint16_t type, uint8_t* buffer, uint32_t length)
{
#ifdef CRC_ENABLE_CRC8
	uint8_t _return = 0;
	switch (type)
	{
		case CRC8_TYPE_NONE:
		{
			_return = 0;
			break;
		}
#ifdef CRC8_ENABLE_TABLE_07H
		case CRC8_TYPE_TABLE_07H:
		case CRC8_TYPE_TABLE_ITU:
		{
			_return = crc_crc8_table(CRC8_TABLE_07H,0x00, buffer, length);
			break;
		}
		case CRC8_TYPE_TABLE_ROHC:
		{
			_return = crc_crc8_table(CRC8_TABLE_07H, 0xFF, buffer, length);
			break;
		}
#endif
#ifdef CRC8_ENABLE_TABLE_31H
		case CRC8_TYPE_TABLE_31H:
		{
			_return = crc_crc8_table(CRC8_TABLE_31H,0X00, buffer, length);
			break;
		}
#endif
#ifdef CRC8_ENABLE_TABLE_5EH
		case CRC8_TYPE_TABLE_5EH:
		{
			_return = crc_crc8_table(CRC8_TABLE_5EH,0X00, buffer, length);
			break;
		}
#endif
#ifdef CRC8_ENABLE_TABLE_9BH
		case CRC8_TYPE_TABLE_9BH:
		{
			_return = crc_crc8_table(CRC8_TABLE_9BH,0X00, buffer, length);
			break;
		}
		case CRC8_TYPE_TABLE_CDMA200:
		{
			_return = crc_crc8_table(CRC8_TABLE_9BH,0XFF, buffer, length);
			break;
		}
#endif
#ifdef CRC8_ENABLE_TABLE_39H
		case CRC8_TYPE_TABLE_39H:
		case CRC8_TYPE_TABLE_DARC:
		{
			_return = crc_crc8_table(CRC8_TABLE_39H, 0X00, buffer, length);
			break;
		}
#endif
#ifdef CRC8_ENABLE_TABLE_D5H
		case CRC8_TYPE_TABLE_D5H:
		case CRC8_TYPE_TABLE_DVBS2:
		{
			_return = crc_crc8_table(CRC8_TABLE_D5H, 0X00, buffer, length);
			break;
		}
#endif
#ifdef CRC8_ENABLE_TABLE_1DH
		case CRC8_TYPE_TABLE_1DH:
		{
			_return = crc_crc8_table(CRC8_TABLE_1DH, 0X00, buffer, length);
			break;
		}
		case CRC8_TYPE_TABLE_EBU:
		{
			_return = crc_crc8_table(CRC8_TABLE_1DH, 0XFF, buffer, length);
			break;
		}
		case CRC8_TYPE_TABLE_ICODE:
		{
			_return = crc_crc8_table(CRC8_TABLE_1DH, 0XFD, buffer, length);
			break;
		}
#endif
#ifdef CRC8_ENABLE_TABLE_2FH
		case CRC8_TYPE_TABLE_2FH:
		{
			_return = crc_crc8_table(CRC8_TABLE_2FH, 0X00, buffer, length);
			break;
		}
#endif
		default:
		{
			_return = 0;
			break;
		}
	}
	return _return;
#else
	return 0
#endif
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参数:
//////输出参数:
//////说		明: 计算校验和
//////////////////////////////////////////////////////////////////////////////
uint8_t crc_check_sum_normal(uint8_t *buffer, uint32_t length)
{
#ifdef CRC_ENABLE_CHECK_SUM
	uint32_t i = 0;
	uint8_t _return = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	for (i = 0; i < length; i++)
	{
		_return += buffer[i];
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	//---计算的校验和
	_return = (uint8_t)(0x100 - _return);
	return _return;
#else
	return 0;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:从指定位置计算校验和
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t crc_check_sum_normal_pos(uint8_t* buffer,uint16_t pos, uint32_t length)
{
#ifdef CRC_ENABLE_CHECK_SUM
	uint32_t i = 0;
	uint8_t _return = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	for (i = 0; i < length; i++)
	{
		_return += buffer[i];
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	//---计算的校验和
	_return = (uint8_t)(0x100 - _return);
	return _return;
#else
	return 0;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:特殊模式计算校验和
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t crc_check_sum_special(uint8_t* buffer, uint32_t length)
{
#ifdef CRC_ENABLE_CHECK_SUM
	uint32_t i = 0;
	uint8_t _return = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	for (i = 0; i < length; i++)
	{
		_return += buffer[i];
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	//---计算的校验和
	_return = (uint8_t)(0xFF - _return);
	return _return;
#else
	return 0;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:特殊模式计算校验和
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t crc_check_sum_special_pos(uint8_t* buffer, uint16_t pos, uint32_t length)
{
#ifdef CRC_ENABLE_CHECK_SUM
	uint32_t i = 0;
	uint8_t _return = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	for (i = 0; i < length; i++)
	{
		_return += buffer[i];
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return _return;
#else
	return 0;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint8_t crc_check_sum_type(uint16_t type,uint8_t* buffer, uint32_t length)
{
	uint8_t _return = 0;
	switch (type)
	{
		case CRC_CHECK_SUM_TYPE_NONE:
		{
			_return = 0;
			break;
		}
		case CRC_CHECK_SUM_TYPE_NORMAL:
		{
			_return = crc_check_sum_normal(buffer,length);
			break;
		}
		case CRC_CHECK_SUM_TYPE_SPECIAL:
		{
			_return = crc_check_sum_special(buffer, length);
			break;
		}
		default:
		{
			_return = 0;
			break;
		}
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参数:
//////输出参数:
//////说		明: 查表实现的CRC16算法
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_table(uint16_t crc_seed, uint16_t crc, uint8_t* buffer, uint32_t length)
{
#ifdef CRC_ENABLE_CRC16
	uint8_t nTemp;
	uint16_t nReg = crc;
	uint32_t index = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	for (index = 0; index < length; index++)
	{
		if (crc == 0xFFFF)
		{
			nTemp = (uint8_t)(nReg ^ buffer[index]);
		}
		else
		{
			nTemp = (uint8_t)((nReg >> 8) ^ buffer[index]);
		}
		//---根据种子计算CRC
		switch (crc_seed)
		{
			case CRC16_TABLE_1021H:
			{
				if (crc == 0xFFFF)
				{
					nReg = (nReg >> 8) ^ g_crc16_table_1021h[nTemp];
				}
				else
				{
					nReg = (nReg << 8) ^ g_crc16_table_1021h[nTemp];
				}
				break;
			}
			case CRC16_TABLE_A001H:
			{
				if (crc == 0xFFFF)
				{
					nReg = (nReg >> 8) ^ g_crc16_table_a001h[nTemp];
				}
				else
				{
					nReg = (nReg << 8) ^ g_crc16_table_a001h[nTemp];
				}
				break;
			}
			case CRC16_TABLE_8005H:
			{
				if (crc == 0xFFFF)
				{
					nReg = (nReg >> 8) ^ g_crc16_table_8005h[nTemp];
				}
				else
				{
					nReg = (nReg << 8) ^ g_crc16_table_8005h[nTemp];
				}
				break;
			}
			case CRC16_TABLE_3D65H:
			{
				if (crc == 0xFFFF)
				{
					nReg = (nReg >> 8) ^ g_crc16_table_3d65h[nTemp];
				}
				else
				{
					nReg = (nReg << 8) ^ g_crc16_table_3d65h[nTemp];
				}
			}
			default:
				break;
		}
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return nReg;
#else
	return 0;
#endif
}


///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_ccitt(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0x0000;
	uint16_t wCPoly = 0x1021;
	uint8_t wChar = 0;
	uint8_t i = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---循环校验
	while (length--)
	{
		wChar = *(buffer++);
		wChar = invert_uint8(&wChar);
		wCRCin ^= (wChar << 8);
		//---逐位计算
		for (i = 0; i < 8; i++)
		{
			if (wCRCin & 0x8000)
			{
				wCRCin = (wCRCin << 1) ^ wCPoly;
			}
			else
			{
				wCRCin = wCRCin << 1;
			}
		}
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return invert_uint16(&wCRCin);
}
///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_table_ccitt(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0x0000;
	uint16_t index = 0;
	uint8_t wChar = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	for (index = 0; index < length; index++)
	{
		wChar = (uint8_t)(wCRCin ^ buffer[index]);
		wCRCin = (wCRCin >> 8) ^ g_crc16_table_ccitt[wChar];
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return wCRCin;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_ccitt_false(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0xFFFF;
	uint16_t wCPoly = 0x1021;
	uint8_t wChar = 0;
	uint8_t i = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---循环校验
	while (length--)
	{
		wChar = *(buffer++);
		wCRCin ^= (wChar << 8);
		//---逐位计算
		for (i = 0; i < 8; i++)
		{
			if (wCRCin & 0x8000)
			{
				wCRCin = (wCRCin << 1) ^ wCPoly;
			}
			else
			{
				wCRCin = wCRCin << 1;
			}
		}
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return wCRCin;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_table_ccitt_false(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0xFFFF;
	uint16_t index = 0;
	uint8_t wChar = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	for (index = 0; index < length; index++)
	{
		wChar = (uint8_t)((wCRCin >> 8) ^ buffer[index]);
		wCRCin = (wCRCin << 8) ^ g_crc16_table_1021h[wChar];
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return wCRCin;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_xmodem(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0x0000;
	uint16_t wCPoly = 0x1021;
	uint8_t wChar = 0;
	uint8_t i = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---循环校验
	while (length--)
	{
		wChar = *(buffer++);
		wCRCin ^= (wChar << 8);
		//---逐位计算
		for (i = 0; i < 8; i++)
		{
			if (wCRCin & 0x8000)
			{
				wCRCin = (wCRCin << 1) ^ wCPoly;
			}
			else
			{
				wCRCin = wCRCin << 1;
			}
		}
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return wCRCin;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_table_xmodem(uint8_t* buffer, uint32_t length)
{
	return crc_crc16_table(CRC16_TABLE_1021H, 0x0000, buffer, length);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_x25(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0xFFFF;
	uint16_t wCPoly = 0x1021;
	uint8_t wChar = 0;
	uint8_t i = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---循环校验
	while (length--)
	{
		wChar = *(buffer++);
		wChar = invert_uint8(&wChar);
		wCRCin ^= (wChar << 8);
		//---逐位计算
		for (i = 0; i < 8; i++)
		{
			if (wCRCin & 0x8000)
			{
				wCRCin = (wCRCin << 1) ^ wCPoly;
			}
			else
			{
				wCRCin = wCRCin << 1;
			}
		}
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	wCRCin= invert_uint16(&wCRCin);
	return (wCRCin^0xFFFF);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_table_x25(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0xFFFF;
	uint8_t wChar = 0;
	uint16_t index = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---循环校验
	for (index = 0; index < length; index++)
	{
		wChar = (uint8_t)(wCRCin ^ buffer[index]);
		wCRCin = (wCRCin >> 8) ^ g_crc16_table_ccitt[wChar];
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return wCRCin ^ 0xFFFF;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_modbus(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0xFFFF;
	uint16_t wCPoly = 0x8005;
	uint8_t wChar = 0;
	uint8_t i = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---循环校验
	while (length--)
	{
		wChar = *(buffer++);
		wChar = invert_uint8(&wChar);
		wCRCin ^= (wChar << 8);
		//---逐位计算
		for (i = 0; i < 8; i++)
		{
			if (wCRCin & 0x8000)
			{
				wCRCin = (wCRCin << 1) ^ wCPoly;
			}
			else
			{
				wCRCin = wCRCin << 1;
			}
		}
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return invert_uint16(&wCRCin);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_table_modbus(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0xFFFF;
	uint8_t wChar = 0;
	uint16_t index = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---循环校验
	for (index = 0; index < length; index++)
	{
		wChar = (uint8_t)(wCRCin ^ buffer[index]);
		wCRCin = (wCRCin >> 8) ^ g_crc16_table_a001h[wChar];
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return wCRCin;
}


///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_ibm(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0x0000;
	uint16_t wCPoly = 0x8005;
	uint8_t wChar = 0;
	uint8_t i = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---循环校验
	while (length--)
	{
		wChar = *(buffer++);
		wChar = invert_uint8(&wChar);
		wCRCin ^= (wChar << 8);
		//---逐位计算
		for (i = 0; i < 8; i++)
		{
			if (wCRCin & 0x8000)
			{
				wCRCin = (wCRCin << 1) ^ wCPoly;
			}
			else
			{
				wCRCin = wCRCin << 1;
			}
		}
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return invert_uint16(&wCRCin);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_table_ibm(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0x0000;
	uint8_t wChar = 0;
	uint16_t i = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	for (i = 0; i < length; i++)
	{
		wChar = (uint8_t)((wCRCin & 0xFF) ^ (buffer[i] & 0xFF));
		wCRCin = ((wCRCin >> 8) & 0xFF) ^ g_crc16_table_a001h[wChar];
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return wCRCin;
}


///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_maxim(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0x0000;
	uint16_t wCPoly = 0x8005;
	uint8_t wChar = 0;
	uint8_t i = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---循环校验
	while (length--)
	{
		wChar = *(buffer++);
		wChar = invert_uint8(&wChar);
		wCRCin ^= (wChar << 8);
		//---逐位计算
		for (i = 0; i < 8; i++)
		{
			if (wCRCin & 0x8000)
			{
				wCRCin = (wCRCin << 1) ^ wCPoly;
			}
			else
			{
				wCRCin = wCRCin << 1;
			}
		}
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	wCRCin = invert_uint16(&wCRCin);
	return (wCRCin ^ 0xFFFF);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_table_maxim(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0x0000;
	uint8_t wChar = 0;
	uint16_t i = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	for (i = 0; i < length; i++)
	{
		wChar = (uint8_t)((wCRCin & 0xFF) ^ (buffer[i] & 0xFF));
		wCRCin = ((wCRCin >> 8) & 0xFF) ^ g_crc16_table_a001h[wChar];
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return wCRCin ^ 0xFFFF;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_usb(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0xFFFF;
	uint16_t wCPoly = 0x8005;
	uint8_t wChar = 0;
	uint8_t i = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---循环校验
	while (length--)
	{
		wChar = *(buffer++);
		wChar = invert_uint8(&wChar);
		wCRCin ^= (wChar << 8);
		//---逐位计算
		for (i = 0; i < 8; i++)
		{
			if (wCRCin & 0x8000)
			{
				wCRCin = (wCRCin << 1) ^ wCPoly;
			}
			else
			{
				wCRCin = wCRCin << 1;
			}
		}
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	wCRCin = invert_uint16(&wCRCin);
	return (wCRCin ^ 0xFFFF);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_table_usb(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0xFFFF;
	uint8_t wChar = 0;
	uint16_t i = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	for (i = 0; i < length; i++)
	{
		wChar = (uint8_t)((wCRCin & 0xFF) ^ (buffer[i] & 0xFF));
		wCRCin = ((wCRCin >> 8) & 0xFF) ^ g_crc16_table_a001h[wChar];
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return wCRCin ^ 0xFFFF;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_rtu(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0xFFFF;
	uint16_t wCPoly = 0xA001;
	uint8_t wChar = 0;
	uint8_t i = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---循环校验
	while (length--)
	{
		wChar = *(buffer++);
		wCRCin ^= (wChar);
		//---逐位计算
		for (i = 0; i < 8; i++)
		{
			if ((wCRCin & 0x01)!=0)
			{
				wCRCin = (wCRCin >> 1) ^ wCPoly;
			}
			else
			{
				wCRCin = wCRCin >> 1;
			}
		}
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return wCRCin;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_table_rtu(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0xFFFF;
	uint8_t wChar = 0;
	uint16_t index = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---循环校验
	for (index = 0; index < length; index++)
	{
		wChar = (uint8_t)(wCRCin ^ buffer[index]);
		wCRCin = (wCRCin >> 8) ^ g_crc16_table_a001h[wChar];
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return wCRCin;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_dnp(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0x0000;
	uint16_t wCPoly = 0x3D65;
	uint8_t wChar = 0;
	uint8_t i = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	//---循环校验
	while (length--)
	{
		wChar = *(buffer++);
		wCRCin ^= (wChar);
		//---逐位计算
		for (i = 0; i < 8; i++)
		{
			if ((wCRCin & 0x01) != 0)
			{
				wCRCin = (wCRCin >> 1) ^ wCPoly;
			}
			else
			{
				wCRCin = wCRCin >> 1;
			}
		}
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return (wCRCin^0xFFFF);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_table_dnp(uint8_t* buffer, uint32_t length)
{
	uint16_t wCRCin = 0x0000;
	uint8_t wChar = 0;
	uint16_t index = 0;
	//---循环校验
	for (index = 0; index < length; index++)
	{
		wChar = (uint8_t)(wCRCin ^ buffer[index]);
		wCRCin = (wCRCin >> 8) ^ g_crc16_table_3d65h[wChar];
	}
	return wCRCin ^ 0xFFFF;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_type(uint16_t type, uint8_t* buffer, uint32_t length)
{
	uint16_t _return = 0;
#ifdef CRC_ENABLE_CRC16
	switch (type)
	{
		case CRC16_TYPE_NONE:
		{
			_return = 0;
			break;
		}
#ifdef CRC16_ENABLE_TABLE_1021H
		case CRC16_TYPE_TABLE_1021H:
		case CRC16_TYPE_TABLE_1021H_0:
		{
			_return = crc_crc16_table(CRC16_TABLE_1021H, 0x0000, buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_1021H_1:
		{
			_return = crc_crc16_table(CRC16_TABLE_1021H, 0xFFFF, buffer, length);
			break;
		}
#endif
#ifdef CRC16_ENABLE_CITT
		case CRC16_TYPE_CCITT:
		{
			_return = crc_crc16_ccitt(buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_CCITT:
		{
			_return = crc_crc16_table_ccitt(buffer, length);
			break;
		}
#endif
#ifdef CRC16_ENABLE_CITT_FALSE
		case CRC16_TYPE_CCITT_FALSE:
		{
			_return = crc_crc16_ccitt_false(buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_CCITT_FALSE:
		{
			_return = crc_crc16_table_ccitt_false(buffer, length);
			break;
		}
#endif
#ifdef CRC16_ENABLE_XMODE
		case CRC16_TYPE_XMODEM:
		{
			_return = crc_crc16_xmodem(buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_XMODEM:
		{
			_return = crc_crc16_table_xmodem(buffer, length);
			break;
		}
#endif
#ifdef CRC16_ENABLE_X25
		case CRC16_TYPE_X25:
		{
			_return = crc_crc16_x25(buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_X25:
		{
			_return = crc_crc16_table_x25(buffer, length);
			break;
		}
#endif
#ifdef CRC16_ENABLE_MODBUS
		case CRC16_TYPE_MODBUS:
		{
			_return = crc_crc16_modbus(buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_MODBUS:
		{
			_return = crc_crc16_table_modbus(buffer, length);
			break;
		}
#endif
#ifdef CRC16_ENABLE_IBM
		case CRC16_TYPE_IBM:
		{
			_return = crc_crc16_ibm(buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_IBM:
		{
			_return = crc_crc16_table_ibm(buffer, length);
			break;
		}
#endif
#ifdef CRC16_ENABLE_MAXIM
		case CRC16_TYPE_MAXIM:
		{
			_return = crc_crc16_maxim(buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_MAXIM:
		{
			_return = crc_crc16_table_maxim(buffer, length);
			break;
		}
#endif
#ifdef CRC16_ENABLE_USB
		case CRC16_TYPE_USB:
		{
			_return = crc_crc16_usb(buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_USB:
		{
			_return = crc_crc16_table_usb(buffer, length);
			break;
		}
#endif
#ifdef CRC16_ENABLE_RTU
		case CRC16_TYPE_RTU:
		{
			_return = crc_crc16_rtu(buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_RTU:
		{
			_return = crc_crc16_table_rtu(buffer, length);
			break;
		}
#endif
#ifdef CRC16_ENABLE_DNP
		case CRC16_TYPE_DNP:
		{
			_return = crc_crc16_dnp(buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_DNP:
		{
			_return = crc_crc16_table_dnp(buffer, length);
			break;
		}
#endif
#ifdef CRC16_ENABLE_TABLE_A001H
		case CRC16_TYPE_TABLE_A001H:
		case CRC16_TYPE_TABLE_A001H_0:
		{
			_return = crc_crc16_table(CRC16_TABLE_A001H,0x0000, buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_A001H_1:
		{
			_return = crc_crc16_table(CRC16_TABLE_A001H,0xFFFF, buffer, length);
			break;
		}
#endif
#ifdef CRC16_ENABLE_TABLE_8005H
		case CRC16_TYPE_TABLE_8005H:
		case CRC16_TYPE_TABLE_8005H_0:
		{
			_return = crc_crc16_table(CRC16_TABLE_8005H, 0x0000, buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_8005H_1:
		{
			_return = crc_crc16_table(CRC16_TABLE_8005H, 0xFFFF, buffer, length);
			break;
		}
#endif
#ifdef CRC16_ENABLE_TABLE_RTU
		case CRC16_TYPE_TABLE_RTU_0:
		{
			_return = crc_crc16_table(CRC16_TABLE_RTU, 0x0000, buffer, length);
			break;
		}
		case CRC16_TYPE_TABLE_RTU_1:
		{
			_return = crc_crc16_table(CRC16_TABLE_RTU, 0xFFFF, buffer, length);
			break;
		}
#endif
		default:
		{
			_return = 0x0000;
			break;
		}
	}
#endif
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能:提供crc种子和crc的值查表计算crc
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint16_t crc_crc16_table_seed_data(uint16_t crc_seed, uint16_t crc_data, uint8_t* buffer, uint32_t length)
{
#ifdef CRC_ENABLE_CRC16
	uint8_t nTemp;
	uint16_t nReg = crc_data;
	uint32_t index = 0;
	//---获取时间标签
	uint32_t cnt = crc_time_tick();
	for (index = 0; index < length; index++)
	{
		nTemp = (uint8_t)((nReg >> 8) ^ buffer[index]);
		switch (crc_seed)
		{
			case CRC16_TABLE_1021H:
			{
				nReg = (nReg << 8) ^ g_crc16_table_1021h[nTemp];
				break;
			}
			case CRC16_TABLE_A001H:
			{
				nReg = (nReg << 8) ^ g_crc16_table_a001h[nTemp];
				break;
			}
			case CRC16_TABLE_8005H:
			{
				nReg = (nReg << 8) ^ g_crc16_table_8005h[nTemp];
				break;
			}
			case CRC16_TABLE_3D65H:
			{
				nReg = (nReg << 8) ^ g_crc16_table_3d65h[nTemp];
				break;
			}
			default:
				break;
		}
		//---校验是否超时
		if (TIME_SPAN(crc_time_tick(), cnt) > CRC_WAIT_MAX_TIME)
		{
			//---更新时间标签
			cnt = crc_time_tick();
			//---喂狗
			WDT_RESET();
		}
	}
	return nReg;
#else
	return 0;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：计算crc16种子表
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
uint8_t crc_crc16_calc_table(uint16_t crcseed,uint16_t *crctable)
{
	uint16_t i = 0,j=0;
	uint16_t crc = 0;
	for (i=0;i<256;i++)
	{
		crc = (i << 8);
		for (j=0;j<8;j++)
		{
			if ((crc&0x8000)!=0)
			{
				crc = (crc << 1) ^ crcseed;
			}
			else
			{
				crc <<= 1;
			}
		}
		crctable[i] = crc;
	}
	return OK_0;
}


///////////////////////////////////////////////////////////////////////////////
//////函		数：
//////功		能：
//////输入参	数：
//////输出参	数：
//////说		明：
//////////////////////////////////////////////////////////////////////////////
void my_crc_init(MY_CRC_HandleType* CRCx, uint32_t(*func_time_tick)(void))
{
	crc_init(func_time_tick);
	//---判断CRC是否为空
	if (CRCx != NULL)
	{
		CRCx->msg_f_crc32_type = crc_crc32_type;
		CRCx->msg_f_crc16_type = crc_crc16_type;
		CRCx->msg_f_crc8_type = crc_crc8_type;
		CRCx->msg_f_check_sum_type = crc_check_sum_type;
	}
}
