#include "ms1022_cfg.h"

//===>>>给定的查表数据只有0到100摄氏度的数据，不在此范围的都是异常数据===开始

//===不同温度下水的粘度pa.s

const float g_viscosity_table[101] = 
{
	/*   0       1       2       3       4       5       6       7       8       9  */
	/*00*/0.001709, 0.001662, 0.001616, 0.001573, 0.001530, 0.001490, 0.001450, 0.001413, 0.001376, 0.001341,
	/*10*/0.001307, 0.001274, 0.001243, 0.001212, 0.001182, 0.001154, 0.001126, 0.001100, 0.001074, 0.001049,
	/*20*/0.001025, 0.001002, 0.000979, 0.000957, 0.000936, 0.000916, 0.000896, 0.000876, 0.000858, 0.000840,
	/*30*/0.000822, 0.000805, 0.000789, 0.000773, 0.000757, 0.000742, 0.000727, 0.000713, 0.000699, 0.000686,
	/*40*/0.000673, 0.000660, 0.000648, 0.000636, 0.000624, 0.000613, 0.000602, 0.000591, 0.000581, 0.000571,
	/*50*/0.000561, 0.000551, 0.000542, 0.000533, 0.000524, 0.000515, 0.000507, 0.000499, 0.000491, 0.000483,
	/*60*/0.000475, 0.000468, 0.000461, 0.000454, 0.000447, 0.000440, 0.000433, 0.000427, 0.000421, 0.000415,
	/*70*/0.000409,	0.000403, 0.000397, 0.000392, 0.000386, 0.000381, 0.000376, 0.000371, 0.000366, 0.000361,
	/*80*/0.000356, 0.000351, 0.000347, 0.000343, 0.000338, 0.000334, 0.000330, 0.000326, 0.000322, 0.000318,
	/*90*/0.000314, 0.000310, 0.000307, 0.000303, 0.000300, 0.000296, 0.000293, 0.000289, 0.000286, 0.000283,
	/*100*/0.000280
};

//===不同温度下水的密度 <1Mpa
const float g_density_table[101] =
{
	/*   0       1       2       3       4       5       6       7       8       9  */
	/*00*/1000.2, 1000.2, 1000.2, 1000.2, 1000.2, 1000.2, 1000.2, 1000.1,1000.1, 1000,
	/*10*/999.9, 999.84, 999.74, 999.61, 999.48, 999.34, 999.18,999.01, 998.83, 998.64,
	/*20*/998.44, 998.22, 98, 997.77, 997.52, 997.2, 997.01, 996.74,996.46, 996.17,
	/*30*/995.87, 995.56, 995.25, 994.93, 994.59, 994.25, 993.91,993.55, 993.19, 992.81,
	/*40*/992.44, 992.05, 991.65, 991.25, 990.85, 990.43, 990.01,989.58, 989.14, 988.7,
	/*50*/988.25, 987.8, 987.33, 986.87, 986.39, 985.91, 985.42,984.93, 984.43, 983.93,
	/*60*/983.41, 982.9, 982.37, 981.84, 981.31, 980.77, 980.22,979.67, 979.12, 978.55,
	/*70*/977.98, 977.41, 976.83, 976.25, 975.66, 975.06, 974.46,973.86, 973.25, 972.63,
	/*80*/972.01, 971.39, 970.76, 970.12, 969.48, 968.84, 968.19,967.53, 966.87, 966.21,
	/*90*/965.54, 964.86, 964.18, 963.5, 962.81, 962.12, 961.42,960.72, 960.01, 959.3,
	/*100*/958.58
};
//===不同温度下水的热焓值<1Mpa
const float g_enthalpy_table[101]=
{
	/*   0       1       2       3       4       5       6       7       8       9  */
	/*00*/4.784, 8.996, 13.206, 17.412, 21.616, 25.818, 30.018, 34.215,38.411,
	/*10*/42.605, 46.798, 50.989, 55.178, 59.367, 03.554, 67.740,71.926, 76.110,
	/*20*/80.294, 84.476, 88.659, 92.840, 97.021, 101.200, 105.380,109.560, 113.740,
	/*30*/117.920, 122.100, 126.280, 130.460, 134.630, 138.810,142.990, 147.170, 151.350,
	/*40*/155.520, 159.700, 163.880, 168.060, 172.240, 176.410,180.590, 184.770, 188.950,
	/*50*/193.130, 197.310, 201.490, 205.670, 209.850, 214.030,218.210, 222.390, 226.570,
	/*60*/230.750, 234.940, 239.120, 243.300, 247.480, 251.670,255.850, 260.040, 264.220,
	/*70*/268.410, 272.590, 270.780, 280.970, 285.150, 289.340,293.530, 297.720, 301.910,
	/*80*/306.100, 310.290, 314.480, 318.680, 322.870, 327.060,331.260, 335.450, 339.650,
	/*90*/343.850, 348.040, 352.240, 356.440, 360.640, 364.840,369.040, 373.250, 377.450,
	/*100*/381.650
};

#ifdef MS1022_ENABLE_PT1000
//===PT1000电阻不同温度下对应电阻值
const float g_pt_table[101][10] =
{
	/* 0.0 *//* 0.1 *//* 0.2 *//* 0.3 *//* 0.4*//* 0.5 *//* 0.6 *//* 0.7 *//* 0.8 *//* 0.9*/
	/*0*/{ 1000, 1000.391, 1000.782, 1001.172, 1001.563, 1001.954, 1002.345,1002.736, 1003.126, 1003.517 },
	/*1*/{ 1003.908, 1004.298, 1004.689, 1005.08, 1005.47, 1005.861, 1006.252,1006.642, 1007.033, 1007.424 },
	/*2*/{ 1007.814, 1008.205, 1008.595, 1008.986, 1009.377, 1009.767, 1010.158,1010.548, 1010.939, 1011.329 },
	/*3*/{ 1011.72, 1012.11, 1012.501, 1012.891, 1013.282, 1013.672, 1014.062,1014.453, 1014.843, 1015.234 },
	/*4*/{ 1015.624, 1016.014, 1016.405, 1016.795, 1017.185, 1017.576, 1017.966,1018.356, 1018.747, 1019.137 },
	/*5*/{ 1019.527, 1019.917, 1020.308, 1020.698, 1021.088, 1021.478, 1021.868,1022.259, 1022.649, 1023.039 },
	/*6*/{ 1023.429, 1023.819, 1024.209, 1024.599, 1024.989, 1025.38, 1025.77,1026.16, 1026.55, 1026.94 },
	/*7*/{ 1027.33, 1027.72, 1028.11, 1028.5, 1028.89, 1029.28, 1029.67, 1030.06,1030.45, 1030.84 },
	/*8*/{ 1031.229, 1031.619, 1032.009, 1032.399, 1032.789, 1033.179, 1033.569,1033.958, 1034.348, 1034.738 },
	/*9*/{ 1035.128, 1035.518, 1035.907, 1036.297, 1036.687, 1037.077, 1037.466,1037.856, 1038.246, 1038.636 },
	/*10*/{ 1039.025, 1039.415, 1039.805, 1040.194, 1040.584, 1040.973, 1041.363,1041.753, 1042.142, 1042.532 },
	/*11*/{ 1042.921, 1043.311, 1043.701, 1044.09, 1044.48, 1044.869, 1045.259,1045.648, 1046.038, 1046.427 },
	/*12*/{ 1046.816, 1047.206, 1047.595, 1047.985, 1048.374, 1048.764, 1049.153,1049.542, 1049.932, 1050.321 },
	/*13*/{ 1050.71, 1051.1, 1051.489, 1051.878, 1052.268, 1052.657, 1053.046,1053.435, 1053.825, 1054.214 },
	/*14*/{ 1054.603, 1054.992, 1055.381, 1055.771, 1056.16, 1056.549, 1056.938,1057.327, 1057.716, 1058.105 },
	/*15*/{ 1058.495, 1058.884, 1059.273, 1059.662, 1060.051, 1060.44, 1060.829,1061.218, 1061.607, 1061.996 },
	/*16*/{ 1062.385, 1062.774, 1063.163, 1063.552, 1063.941, 1064.33, 1064.719,1065.108, 1065.496, 1065.885 },
	/*17*/{ 1066.274, 1066.663, 1067.052, 1067.441, 1067.83, 1068.218, 1068.607,1068.996, 1069.385, 1069.774 },
	/*18*/{ 1070.162, 1070.551, 1070.94, 1071.328, 1071.717, 1072.106, 1072.495,1072.883, 1073.272, 1073.661 },
	/*19*/{ 1074.049, 1074.438, 1074.826, 1075.215, 1075.604, 1075.992, 1076.381,1076.769, 1077.158, 1077.546 },
	/*20*/{ 1077.935, 1078.324, 1078.712, 1079.101, 1079.489, 1079.877, 1080.266,1080.654, 1081.043, 1081.431 },
	/*21*/{ 1018.82, 1082.208, 1145.596, 1208.985, 1272.373, 1335.762, 1399.15,1462.538, 1525.926, 1589.315 },
	/*22*/{ 1085.703, 1086.091, 1086.48, 1086.868, 1087.256, 1087.644, 1088.033,1088.421, 1088.809, 1089.197 },
	/*23*/{ 1089.585, 1089.974, 1090.362, 1090.75, 1091.138, 1091.526, 1091.914,1092.302, 1092.69, 1093.078 },
	/*24*/{ 1093.467, 1093.855, 1094.243, 1094.631, 1095.019, 1095.407, 1095.795,1096.183, 1096.571, 1096.959 },
	/*25*/{ 1097.347, 1097.734, 1098.122, 1098.51, 1098.898, 1099.286, 1099.674,1100.062, 1100.45, 1100.838 },
	/*26*/{ 1101.225, 1101.613, 1102.001, 1102.389, 1102.777, 1103.164, 1103.552,1103.94, 1104.328, 1104.715 },
	/*27*/{ 1105.103, 1105.491, 1105.879, 1106.266, 1106.654, 1107.042, 1107.429,1107.817, 1108.204, 1108.592 },
	/*28*/{ 1108.98, 1109.367, 1109.755, 1110.142, 1110.53, 1110.917, 1111.305,1111.693, 1112.08, 1112.468 },
	/*29*/{ 1112.855, 1113.242, 1113.63, 1114.017, 1114.405, 1114.792, 1115.18,1115.567, 1115.954, 1116.342 },
	/*30*/{ 1116.729, 1117.117, 1117.504, 1117.891, 1118.279, 1118.666, 1119.053,1119.441, 1119.828, 1120.215 },
	/*31*/{ 1120.602, 1120.99, 1121.377, 1121.764, 1122.151, 1122.538, 1122.926,1123.313, 1123.7, 1124.087 },
	/*32*/{ 1124.474, 1124.861, 1125.248, 1125.636, 1126.023, 1126.41, 1126.797,1127.184, 1127.571, 1127.958 },
	/*33*/{ 1139.95, 1140.337, 1140.724, 1141.11, 1141.497, 1141.884, 1142.27,1142.657, 1143.043, 1143.43 },
	/*34*/{ 1132.215, 1132.602, 1132.988, 1133.375, 1133.762, 1134.149, 1134.536,1134.923, 1135.309, 1135.696 },
	/*35*/{ 1136.083, 1136.47, 1136.857, 1137.243, 1137.63, 1138.017, 1138.404,1138.79, 1139.177, 1139.564 },
	/*36*/{ 1139.95, 1140.337, 1140.724, 1141.11, 1141.497, 1141.884, 1142.27,1142.657, 1143.043, 1143.43 },
	/*37*/{ 1143.817, 1144.203, 1144.59, 1144.976, 1145.363, 1145.749, 1146.136,1146.522, 1146.909, 1147.295 },
	/*38*/{ 1147.681, 1148.068, 1148.454, 1148.841, 1149.227, 1149.614, 1150,1150.386, 1150.773, 1151.159 },
	/*39*/{ 1151.545, 1151.932, 1152.318, 1152.704, 1153.091, 1153.477, 1153.863,1154.249, 1154.636, 1155.022 },
	/*40*/{ 1155.408, 1155.794, 1156.18, 1156.567, 1156.953, 1157.339, 1157.725,1158.111, 1158.497, 1158.883 },
	/*41*/{ 1159.27, 1159.656, 1160.042, 1160.428, 1160.814, 1161.2, 1161.586,1161.972, 1162.358, 1162.744 },
	/*42*/{ 1163.13, 1163.516, 1163.902, 1164.288, 1164.674, 1165.06, 1165.446,1165.831, 1166.217, 1166.603 },
	/*43*/{ 1166.989, 1167.375, 1167.761, 1168.147, 1168.532, 1168.918, 1169.304,1169.69, 1170.076, 1170.461 },
	/*44*/{ 1170.847, 1171.233, 1171.619, 1172.004, 1172.39, 1172.776, 1173.161,1173.547, 1173.933, 1174.318 },
	/*45*/{ 1174.704, 1175.09, 1175.475, 1175.861, 1176.247, 1176.632, 1177.018,1177.403, 1177.789, 1178.174 },
	/*46*/{ 1178.56, 1178.945, 1179.331, 1179.716, 1180.102, 1180.487, 1180.873,1181.258, 1181.644, 1182.029 },
	/*47*/{ 1182.414, 1182.8, 1183.185, 1183.571, 1183.956, 1184.341, 1184.727,1185.112, 1185.597, 1185.883 },
	/*48*/{ 1186.268, 1186.653, 1187.038, 1187.424, 1187.809, 1188.194, 1188.579,1188.965, 1189.35, 1189.735 },
	/*49*/{ 1190.12, 1190.505, 1190.89, 1191.276, 1191.661, 1192.046, 1192.431,1192.816, 1193.201, 1193.586 },
	/*50*/{ 1193.971, 1194.356, 1194.741, 1195.126, 1195.511, 1195.896, 1196.281,1196.666, 1197.051, 1197.436 },
	/*51*/{ 1197.821, 1198.206, 1198.591, 1198.976, 1199.361, 1199.746, 1200.131,1200.516, 1200.9, 1201.285 },
	/*52*/{ 1201.67, 1202.055, 1202.44, 1202.824, 1203.209, 1203.594, 1203.979,1204.364, 1204.748, 1205.133 },
	/*53*/{ 1205.518, 1205.902, 1206.287, 1206.672, 1207.056, 1207.441, 1207.826,1208.21, 1208.595, 1208.98 },
	/*54*/{ 1209.364, 1209.749, 1210.133, 1210.518, 1210.902, 1211.287, 1211.672,1212.056, 1212.441, 1212.825 },
	/*55*/{ 1213.21, 1213.594, 1213.978, 1214.363, 1214.747, 1215.12, 1215.516,1215.901, 1216.285, 1216.669 },
	/*56*/{ 1217.054, 1217.438, 1217.822, 1218.207, 1218.591, 1218.975, 1219.36,1219.744, 1220.128, 1220.513 },
	/*57*/{ 1220.897, 1221.281, 1221.665, 1222.049, 1222.434, 1222.818, 1223.202,1223.586, 1223.97, 1224.355 },
	/*58*/{ 1224.739, 1225.123, 1225.507, 1225.891, 1226.275, 1226.659, 1227.043,1227.427, 1227.811, 1228.195 },
	/*59*/{ 1228.579, 1228.963, 1229.347, 1229.731, 1230.115, 1230.499, 1230.883,1231.267, 1231.651, 1232.035 },
	/*60*/{ 1232.419, 1232.803, 1233.187, 1233.571, 1233.955, 1234.338, 1234.722,1235.106, 1235.49, 1235.874 },
	/*61*/{ 1236.257, 1236.641, 1237.025, 1237.409, 1237.792, 1238.176, 1238.56,1238.944, 1239.327, 1239.711 },
	/*62*/{ 1240.095, 1240.478, 1240.862, 1241.246, 1241.629, 1242.03, 1242.396,1242.78, 1243.164, 1243.547 },
	/*63*/{ 1243.931, 1244.314, 1244.698, 1245.081, 1245.465, 1245.848, 1246.232,1246.615, 1246.999, 1247.382 },
	/*64*/{ 1247.766, 1248.149, 1248.533, 1248.916, 1249.299, 1249.683, 1250.066,1250.45, 1250.833, 1251.216 },
	/*65*/{ 1251.6, 1251.983, 1252.366, 1252.749, 1253.133, 1253.516, 1253.899,1254.283, 1254.666, 1255.049 },
	/*66*/{ 1255.432, 1255.815, 1256.199, 1256.582, 1256.965, 1257.348, 1257.731,1258.114, 1258.497, 1258.881 },
	/*67*/{ 1259.264, 1259.647, 1260.03, 1260.413, 1260.796, 1261.179, 1261.562,1261.945, 1262.328, 1262.711 },
	/*68*/{ 1263.094, 1263.477, 1263.86, 1264.243, 1264.626, 1265.009, 1265.392,1265.775, 1266.157, 1266.54 },
	/*69*/{ 1266.923, 1267.306, 1267.689, 1268.072, 1268.455, 1268.837, 1269.22,1269.603, 1269.986, 1270.368 },
	/*70*/{ 1270.751, 1271.134, 1271.517, 1271.899, 1272.282, 1272.665, 1273.048,1273.43, 1273.813, 1274.195 },
	/*71*/{ 1274.578, 1274.691, 1274.803, 1274.916, 1275.029, 1275.141, 1275.254,1275.366, 1275.479, 1275.591 },
	/*72*/{ 1278.404, 1278.786, 1279.169, 1279.551, 1279.934, 1280.316, 1280.699,1281.081, 1281.464, 1281.846 },
	/*73*/{ 1282.228, 1282.611, 1282.993, 1283.376, 1283.758, 1284.14, 1284.523,1284.905, 1285.287, 1285.67 },
	/*74*/{ 1286.052, 1286.434, 1286.816, 1287.199, 1287.581, 1287.963, 1288.345,1288.728, 1289.11, 1289.492 },
	/*75*/{ 1289.874, 1290.256, 1290.638, 1291.021, 1291.403, 1291.785, 1292.167,1292.549, 1292.931, 1293.313 },
	/*76*/{ 1293.695, 1294.077, 1294.459, 1294.841, 1295.223, 1295.605, 1295.987,1296.369, 1296.751, 1297.133 },
	/*77*/{ 1297.515, 1297.897, 1298.279, 1298.661, 1299.043, 1299.425, 1299.807,1300.188, 1300.57, 1300.952 },
	/*78*/{ 1301.334, 1301.716, 1302.098, 1302.479, 1302.861, 1303.243, 1303.625,1304.006, 1304.388, 1304.77 },
	/*79*/{ 1305.152, 1305.533, 1305.915, 1306.297, 1306.678, 1307.06, 1307.442,1307.823, 1308.205, 1308.586 },
	/*80*/{ 1308.968, 1309.35, 1309.731, 1310.113, 1310.494, 1310.876, 1311.27,1311.639, 1312.02, 1312.402 },
	/*81*/{ 1312.783, 1313.165, 1313.546, 1313.928, 1314.309, 1314.691, 1315.072,1315.453, 1315.835, 1316.216 },
	/*82*/{ 1316.597, 1316.979, 1317.36, 1317.742, 1318.123, 1318.504, 1318.885,1319.267, 1319.648, 1320.029 },
	/*83*/{ 1320.411, 1320.792, 1321.173, 1321.554, 1321.935, 1322.316, 1322.697,1323.079, 1323.46, 1323.841 },
	/*84*/{ 1324.222, 1324.603, 1324.985, 1325.366, 1325.747, 1326.128, 1326.509,1326.89, 1327.271, 1327.652 },
	/*85*/{ 1328.033, 1328.414, 1328.795, 1329.176, 1329.557, 1329.938, 1330.319,1330.7, 1331.081, 1331.462 },
	/*86*/{ 1331.843, 1332.224, 1332.604, 1332.985, 1333.366, 1333.747, 1334.128,1334.509, 1334.889, 1335.27 },
	/*87*/{ 1335.651, 1336.032, 1336.413, 1336.793, 1337.174, 1337.555, 1337.935,1338.316, 1338.697, 1339.078 },
	/*88*/{ 1339.458, 1335.839, 1332.22, 1328.6, 1324.981, 1321.361, 1317.742,1314.123, 1310.503, 1306.884 },
	/*89*/{ 1343.264, 1343.645, 1344.025, 1344.406, 1344.786, 1345.167, 1345.57,1345.928, 1346.308, 1346.689 },
	/*90*/{ 1347.069, 1347.45, 1347.83, 1348.211, 1348.591, 1348.971, 1349.352,1349.732, 1350.112, 1350.493 },
	/*91*/{ 1350.873, 1351.253, 1351.634, 1352.014, 1352.394, 1352.774, 1353.155,1353.535, 1353.915, 1354.295 },
	/*92*/{ 1354.676, 1355.056, 1355.436, 1355.816, 1356.196, 1356.577, 1356.957,1357.337, 1357.717, 1358.097 },
	/*93*/{ 1358.477, 1358.857, 1359.237, 1359.617, 1359.997, 1360.377, 1360.757,1361.137, 1361.517, 1361.897 },
	/*94*/{ 1362.277, 1362.657, 1363.037, 1363.417, 1363.797, 1364.177, 1364.557,1364.937, 1365.317, 1365.697 },
	/*95*/{ 1366.077, 1366.456, 1366.836, 1367.216, 1367.596, 1367.976, 1368.355,1368.735, 1369.115, 1369.495 },
	/*96*/{ 1369.875, 1370.254, 1370.634, 1371.014, 1371.393, 1371.773, 1372.153,1372.532, 1372.912, 1373.292 },
	/*97*/{ 1373.671, 1374.051, 1374.431, 1374.81, 1375.19, 1375.569, 1375.949,1376.329, 1376.708, 1377.088 },
	/*98*/{ 1377.467, 1377.847, 1378.226, 1378.606, 1378.985, 1379.365, 1379.744,1380.123, 1380.503, 1380.882 },
	/*99*/{ 1381.262, 1381.641, 1382.02, 1382.4, 1382.779, 1383.158, 1383.538,1383.917, 1384.296, 1384.676 },
	/*100*/{ 1385.055, 1385.434, 1385.814, 1386.193, 1386.572, 1386.951, 1387.33,1387.71, 1388.089, 1388.468 } 
};
#endif

//===超声波在不同的温度条件下传播熟读
const float g_sound_speed_table[101] = 
{
	/*   0       1       2       3       4       5       6       7       8       9  */
	/*00*/1402.3, 1407.3, 1412.2, 1416.9, 1421.6, 1426.1, 1430.5, 1434.8, 1439.1,1443.2,
	/*10*/1447.2, 1451.1, 1454.9, 1458.7, 1462.3, 1465.8, 1469.3, 1472.7,1476.0, 1479.1,
	/*20*/1482.3, 1485.3, 1488.2, 1491.1, 1493.9, 1496.6, 1499.2, 1501.8,1504.3, 1506.7,
	/*30*/1509.0, 1511.3, 1513.5, 1515.7, 1517.7, 1519.7, 1521.7, 1523.5,1525.3, 1527.1,
	/*40*/1528.8, 1530.4, 1532.0, 1533.5, 1534.9, 1536.3, 1537.7, 1538.9,1540.2, 1541.3,
	/*50*/1542.5, 1543.5, 1544.6, 1545.5, 1546.4, 1547.3, 1548.1, 1548.9,1549.6, 1550.3,
	/*60*/1550.9, 1551.5, 1552.0, 1552.5, 1553.0, 1553.4, 1553.7, 1554.0,1554.3, 1554.5,
	/*70*/1554.7, 1554.9, 1555.0, 1555.0, 1555.1, 1555.1, 1555.0, 1554.9,1554.8, 1554.6,
	/*80*/1554.4, 1554.2, 1553.9, 1553.6, 1553.2, 1552.8, 1552.4, 1552.0,1551.5, 1551.0,
	/*90*/1550.4, 1549.8, 1549.2, 1548.5, 1547.5, 1547.1, 1546.3, 1545.6,1544.7, 1543.9,
	/*100*/1543.0, 
};

#ifdef MS1022_ENABLE_PT500
//===PT500电阻不同温度下对应电阻值
const float  g_pt_table[101][10] =
{

}
#endif

//===<<<给定的查表数据只有0到100摄氏度的数据，不在此范围的都是异常数据===开始


//===变量定义
MS1022_HandleType			g_ms1022_one = { 0 };
pMS1022_HandleType			p_ms1022_one = &g_ms1022_one;

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_init_one(MS1022_HandleType* MS1022x)
{
	//--->>>配置CSI中断---开始
	ST0 |= _0001_SAU_CH0_STOP_TRG_ON;    
	
	//---不使能中断
	CSIMK00 = 1U;   
	//---清楚中断标志位
	CSIIF00 = 0U;   

	//---设置CSI的中断优先级
	CSIPR100 = 1U;
	CSIPR000 = 1U;

	SIR00 = _0002_SAU_SIRMN_PECTMN | 
			_0001_SAU_SIRMN_OVCTMN;   

	SMR00 = _0020_SAU_SMRMN_INITIALVALUE | 
			_0000_SAU_CLOCK_SELECT_CK00 | 
			_0000_SAU_CLOCK_MODE_CKS |
			_0000_SAU_TRIGGER_SOFTWARE | 
			_0000_SAU_MODE_CSI | 
			_0000_SAU_TRANSFER_END;

	SCR00 = _C000_SAU_RECEPTION_TRANSMISSION | 
			_1000_SAU_TIMING_2 | 
			_0000_SAU_MSB | 
			_0007_SAU_LENGTH_8;

	SDR00 = 0x0000;

	SO0 &= ~_0100_SAU_CH0_CLOCK_OUTPUT_1;    /* CSI00 clock initial level */
	SO0 &= ~_0001_SAU_CH0_DATA_OUTPUT_1;    /* CSI00 SO initial level */
	SOE0 |= _0001_SAU_CH0_OUTPUT_ENABLE;    /* enable CSI00 output */
	
	//---MOSI---SI----P00
	//---MISO---SO----P17
	//---SCK----SCK---P16
	//---SS-----SS----P15
	//---RST----RST---P14
	//---INT----INT---P02

	///* Set SI00 pin */
	//PFSEG5 &= 0xF7U;
	//PM1 |= 0x80U;

	///* Set SO00 pin */
	//PFSEG5 &= 0xEFU;
	//PM0 &= 0xFEU;
	//P0 |= 0x01U;

	///* Set SCK00 pin */
	//PFSEG5 &= 0xFBU;
	//P1 |= 0x40U;
	//PM1 &= 0xBFU;

	MS1022x->msg_spix.msg_gpio_miso.msg_p_port = MS1022_SPI_MISO_PORT_ONE;
	MS1022x->msg_spix.msg_gpio_miso.msg_bit = MS1022_SPI_MISO_BIT_ONE;

	MS1022x->msg_spix.msg_gpio_mosi.msg_p_port = MS1022_SPI_MOSI_PORT_ONE;
	MS1022x->msg_spix.msg_gpio_mosi.msg_bit = MS1022_SPI_MOSI_BIT_ONE;

	MS1022x->msg_spix.msg_gpio_sck.msg_p_port = MS1022_SPI_SCK_PORT_ONE;
	MS1022x->msg_spix.msg_gpio_sck.msg_bit = MS1022_SPI_SCK_BIT_ONE;

	MS1022x->msg_spix.msg_gpio_cs.msg_p_port = MS1022_SPI_CS_PORT_ONE;
	MS1022x->msg_spix.msg_gpio_cs.msg_bit = MS1022_SPI_CS_BIT_ONE;

	MS1022x->msg_gpio_rst.msg_p_port = MS1022_RST_PORT_ONE;
	MS1022x->msg_gpio_rst.msg_bit = MS1022_RST_BIT_ONE;

	//---MISO设置输入模式且上拉打开
	gpio_task_pin_mode_input(MS1022x->msg_spix.msg_gpio_miso.msg_p_port, MS1022x->msg_spix.msg_gpio_miso.msg_bit);
	gpio_task_pin_mode_pull_up_set(MS1022x->msg_spix.msg_gpio_miso.msg_p_port, MS1022x->msg_spix.msg_gpio_miso.msg_bit);

	//---MOSI设置为输出模式且输出为高
	gpio_task_pin_mode_output(MS1022x->msg_spix.msg_gpio_mosi.msg_p_port, MS1022x->msg_spix.msg_gpio_mosi.msg_bit);
	PIN_OUT_1(MS1022x->msg_spix.msg_gpio_mosi.msg_p_port, MS1022x->msg_spix.msg_gpio_mosi.msg_bit);

	//---SCK设置为输出模式且输出为高
	gpio_task_pin_mode_output(MS1022x->msg_spix.msg_gpio_sck.msg_p_port, MS1022x->msg_spix.msg_gpio_sck.msg_bit);
	PIN_OUT_1(MS1022x->msg_spix.msg_gpio_sck.msg_p_port, MS1022x->msg_spix.msg_gpio_sck.msg_bit);

	//---SS设置为输出模式且输出为高
	gpio_task_pin_mode_output(MS1022x->msg_spix.msg_gpio_cs.msg_p_port, MS1022x->msg_spix.msg_gpio_cs.msg_bit);
	PIN_OUT_1(MS1022x->msg_spix.msg_gpio_cs.msg_p_port, MS1022x->msg_spix.msg_gpio_cs.msg_bit);

	//---RST设置为输出模式且输出为0
	gpio_task_pin_mode_output(MS1022x->msg_gpio_rst.msg_p_port, MS1022x->msg_gpio_rst.msg_bit);
	PIN_OUT_1(MS1022x->msg_gpio_rst.msg_p_port, MS1022x->msg_gpio_rst.msg_bit);

	SO0 &= ~_0100_SAU_CH0_CLOCK_OUTPUT_1;   
	SO0 &= ~_0001_SAU_CH0_DATA_OUTPUT_1;    
	SOE0 |= _0001_SAU_CH0_OUTPUT_ENABLE;   
	SS0 |= _0001_SAU_CH0_START_TRG_ON;     
	
	//---清楚中断标志位
	//CSIIF00 = 0U;
	//---使能中断
	//CSIMK00 = 0U;

	//---<<<配置CSI中断---结束

	//--->>>配置端口中断---开始
	//---不使能中断
	PMK7 = 1U;    /* disable INTP7 operation */
	//---清楚中断标志
	PIF7 = 0U;    /* clear INTP7 interrupt flag */
	
	//---设置中断优先级
	PPR17 = 0U;
	PPR07 = 1U;

	//---设置下降沿触发
	EGN0 |= _80_INTP7_EDGE_FALLING_SEL;

	//---设置INT为输入模式且上拉使能
	gpio_task_pin_mode_input(MS1022_INT_PORT_ONE, MS1022_INT_BIT_ONE);
	gpio_task_pin_mode_pull_up_set(MS1022_INT_PORT_ONE, MS1022_INT_BIT_ONE);

	//---清楚中断标志
	PIF7 = 0U;   
	//---使能中断
	PMK7 = 0U; 
	//---<<<配置端口中断---结束
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_init_two(MS1022_HandleType* MS1022x)
{
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_init_three(MS1022_HandleType* MS1022x)
{
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_time_tick_init(MS1022_HandleType* MS1022x, uint32_t(*func_time_tick)(void))
{
	//---注册滴答函数
	(func_time_tick != NULL) ?
		(MS1022x->msg_f_time_tick = func_time_tick) :
		(MS1022x->msg_f_time_tick = sys_tick_task_get_tick);
	//---SPI滴答函数
	spi_task_time_tick_init(&(MS1022x->msg_spix), func_time_tick);
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_init(MS1022_HandleType* MS1022x, void(*func_delay_us)(uint32_t us), 
	void(*func_delay_ms)(uint32_t ms), uint32_t(*func_time_tick)(void), uint8_t is_hw)
{
	uint8_t _return = ERROR_1;
	//---初始化设备1
	if ((MS1022x != NULL) && (MS1022x == MS1022_TASK_ONE))
	{
		ms1022_spi_init_one(MS1022x);
		_return = OK_0;
	}
	//---初始化设备2
	if ((MS1022x != NULL) && (MS1022x == MS1022_TASK_TWO))
	{
		ms1022_spi_init_two(MS1022x);
		_return = OK_0;
	}
	//---初始化设备2
	if ((MS1022x != NULL) && (MS1022x == MS1022_TASK_THREE))
	{
		ms1022_spi_init_three(MS1022x);
		_return = OK_0;
	}

	//---初始化SPI端口
	if (_return==OK_0)
	{
		//---us延时函数
		(func_delay_us != NULL) ?
			(MS1022x->msg_spix.msg_f_delay_us = func_delay_us) :
			(MS1022x->msg_spix.msg_f_delay_us = delay_task_us);
		//---ms延时函数
		(func_delay_us != NULL) ?
			(MS1022x->msg_f_delay_ms = func_delay_ms) :
			(MS1022x->msg_f_delay_ms = delay_task_ms);
		//---注册滴答函数
		(func_time_tick != NULL) ?
			(MS1022x->msg_f_time_tick = func_time_tick) :
			(MS1022x->msg_f_time_tick = sys_tick_task_get_tick);
		//---数据缓存区
		MS1022x->msg_spix.msg_p_send_data_buffer = MS1022x->msg_send_data_buffer;
		MS1022x->msg_spix.msg_p_read_data_buffer = MS1022x->msg_read_data_buffer;
		//---初始化SPI
		spi_task_init(&(MS1022x->msg_spix),func_delay_us,func_time_tick);
		//---判断是硬件还是软件端口
		if (is_hw!=0)
		{
			//---spi硬件初始化
			spi_task_mhw_gpio_init(&(MS1022x->msg_spix));
			MS1022x->msg_spix.msg_pulse_width = 5;
		}
		else
		{
			//---spi软件初始化
			spi_task_msw_gpio_init(&(MS1022x->msg_spix));
		}
		MS1022x->msg_spix.msg_data_count = 0;
		MS1022x->msg_spix.msg_state = 0;
		//---进水口温度系数
		MS1022x->msg_water_temperature.msg_in_temp_factor = 1.0f;
		//---出水口温度系数
		MS1022x->msg_water_temperature.msg_out_temp_factor = 1.0f;
		//---飞行时间系数
		MS1022x->msg_water_tof.msg_time_factor = 1.0f;
		//---管段的类型
		MS1022x->msg_water_transducer.msg_type = 0x15;
		//---两个换能器的中心间距
		MS1022x->msg_water_transducer.msg_space_length = 0.062;
		//---管段的直径
		MS1022x->msg_water_transducer.msg_diameter = 0.015;
		//---初始化复位ms1022
		ms1022_spi_rst(MS1022x);
		//---初始化配置
		_return = ms1022_spi_config_init(MS1022x);
	}

	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 上电复位设备
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_rst(MS1022_HandleType* MS1022x)
{
	PIN_OUT_0(MS1022x->msg_gpio_rst.msg_p_port, MS1022x->msg_gpio_rst.msg_bit);
	delay_task_us(450);
	PIN_OUT_1(MS1022x->msg_gpio_rst.msg_p_port, MS1022x->msg_gpio_rst.msg_bit);
	delay_task_us(450);
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 设置中断标识信号
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_int_flag_set(MS1022_HandleType* MS1022x)
{
	MS1022x->msg_int_flag = 1;
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 清楚中断标识信号
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_int_flag_clear(MS1022_HandleType* MS1022x)
{
	MS1022x->msg_int_flag = 0;
	return OK_0;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 等待中断标识信号
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_int_flag_wait(MS1022_HandleType* MS1022x)
{
	uint8_t _return = OK_0;
	uint32_t cnt = 0;
	//---获取时间标签
	cnt = MS1022x->msg_f_time_tick();
	//---等待中断信号
	while (1)
	{
		//---判断中断标识信号
		if (MS1022x->msg_int_flag!=0)
		{
			//---正常退出
			_return = OK_0;
			break;
		}
		//---判断是否超时
		if (TIME_SPAN(MS1022x->msg_f_time_tick(),cnt)>MS1022_WAIT_FLAG_MAX_TIME)
		{
			//---超时退出
			_return = ERROR_1;
			break;
		}
		//---喂狗
		WDT_RESET();
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 硬件收发SPI数据
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_mhw_it_byte_buffer(MS1022_HandleType* MS1022x, uint8_t *pval, uint8_t *pcmd, uint16_t length)
{
	uint8_t _return = ERROR_1;
	uint32_t cnt = 0;
	MS1022x->msg_spix.msg_p_send_data_buffer = pval;
	MS1022x->msg_spix.msg_p_read_data_buffer = pcmd;
	if (length>0)
	{
		//---使能数据发送
		PIN_OUT_0(MS1022x->msg_spix.msg_gpio_cs.msg_p_port, MS1022x->msg_spix.msg_gpio_cs.msg_bit);
		//---设置发送数据个数
		MS1022x->msg_spix.msg_data_count = length;
		//---设置spi的工作状态为忙碌中
		MS1022x->msg_spix.msg_state = BUSY;
		//---不使能中断
		CSIMK00 = 1U; 
		//---清楚中断标志位
		CSIIF00 = 0U;
		//---数据发送
		SIO00 = *(MS1022x->msg_spix.msg_p_send_data_buffer);
		//---数据偏移
		MS1022x->msg_spix.msg_p_send_data_buffer++;
		//---发送数据个数减少
		MS1022x->msg_spix.msg_data_count--;
		//---使能中断
		CSIMK00 = 0U;
		//---获取时间标签
		cnt = MS1022x->msg_f_time_tick();
		//---等待数据发送完成
		while (1)
		{
			//---判断发送挖出讷航
			if (MS1022x->msg_spix.msg_state == IDLE)
			{
				_return = OK_0;
				//---正常退出
				break;
			}
			//---数据发送出错
			if (MS1022x->msg_spix.msg_state == ERROR)
			{
				_return = ERROR_2;
				//---正常退出
				break;
			}
			//---判断时间超时
			if (TIME_SPAN(MS1022x->msg_f_time_tick(),cnt)>MS1022_WAIT_IDLE_MAX_TIME)
			{
				_return = ERROR_3;
				//---超时退出
				break;
			}
			//---喂狗
			WDT_RESET();
		}
		//---不使能数据发送
		PIN_OUT_1(MS1022x->msg_spix.msg_gpio_cs.msg_p_port, MS1022x->msg_spix.msg_gpio_cs.msg_bit);
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 硬件中断处理函数
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_mhw_it_irq_handle(MS1022_HandleType* MS1022x)
{
	vltuint16_t err_type = 0;
	err_type= (SSR00 & _0001_SAU_OVERRUN_ERROR);
	//---清楚错误标识
	SIR00 = err_type;
	//---判断错误信息
	if (err_type==0)
	{
		if (MS1022x->msg_spix.msg_data_count != 0)
		{
			//---数据接收
			*(MS1022x->msg_spix.msg_p_read_data_buffer) = SIO00;
			//---数据地址偏移
			MS1022x->msg_spix.msg_p_read_data_buffer++;
			
			//---数据发送
			SIO00 = *(MS1022x->msg_spix.msg_p_send_data_buffer);
			//---数据地址偏移
			MS1022x->msg_spix.msg_p_send_data_buffer++;

			MS1022x->msg_spix.msg_data_count--;
		}
		else
		{
			//---数据接收
			*(MS1022x->msg_spix.msg_p_read_data_buffer) = SIO00;
			//---数据收发完成设置spi的工作状态为完成
			MS1022x->msg_spix.msg_state = IDLE;
		}
		return OK_0;
	}
	else
	{
		//---设置spi的工作状态为错误
		MS1022x->msg_spix.msg_state = ERROR;
	}
	return ERROR_1;
	//return spi_task_mhw_it_irq_handle(&(MS1022x->msg_spix));
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_msw_byte_buffer(MS1022_HandleType* MS1022x, uint8_t *pval, uint8_t *pcmd, uint16_t length)
{
	uint8_t _return = OK_0;
	//---使能数据发送
	PIN_OUT_0(MS1022x->msg_spix.msg_gpio_cs.msg_p_port, MS1022x->msg_spix.msg_gpio_cs.msg_bit);
	//---数据收发
	_return= spi_task_msw_msb_byte_buffer(&(MS1022x->msg_spix), pval, pcmd, length);
	//---不使能数据发送
	PIN_OUT_1(MS1022x->msg_spix.msg_gpio_cs.msg_p_port, MS1022x->msg_spix.msg_gpio_cs.msg_bit);
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_byte_buffer(MS1022_HandleType* MS1022x, uint8_t *pval, uint8_t *pcmd, uint16_t length)
{
	if (MS1022x->msg_spix.msg_hw_mode==0)
	{
		return ms1022_spi_msw_byte_buffer(&(MS1022x->msg_spix), pval, pcmd, length);
	}
	else
	{
		return ms1022_spi_mhw_it_byte_buffer(&(MS1022x->msg_spix), pval, pcmd, length);
	}
	//return ms1022_spi_mhw_it_byte_buffer(&(MS1022x->msg_spix), pval, pcmd, length);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 读取指定寄存器的值
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_read_reg(MS1022_HandleType* MS1022x, uint8_t index)
{
	memset(MS1022x->msg_send_data_buffer,0xFF,MS1022_DATA_BUFFER_MAX_SIZE);
	MS1022x->msg_send_data_buffer[0] = index | MS1022_READ_ADDR_MASK;
	return ms1022_spi_byte_buffer(MS1022x, MS1022x->msg_send_data_buffer, MS1022x->msg_read_data_buffer, 5);
}


///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 讲数据写入到指定的寄存器中
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_send_reg(MS1022_HandleType* MS1022x, uint8_t index,uint32_t val)
{
	if (index==0)
	{
		val &= MS1022_REG_START_CAL_RESONATOR_VAL;
		val |= MS1022_REG_START_CAL_RESONATOR_MASK;
	}
	MS1022x->msg_send_data_buffer[0] = index | MS1022_SEND_ADDR_MASK;
	MS1022x->msg_send_data_buffer[1] = (uint8_t)(val >> 24);
	MS1022x->msg_send_data_buffer[2] = (uint8_t)(val >> 16);
	MS1022x->msg_send_data_buffer[3] = (uint8_t)(val >> 8);
	MS1022x->msg_send_data_buffer[4] = (uint8_t)(val >> 0);
	return ms1022_spi_byte_buffer(MS1022x, MS1022x->msg_send_data_buffer, MS1022x->msg_read_data_buffer, 5);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 发送命令
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_send_cmd(MS1022_HandleType* MS1022x, uint8_t cmd)
{
	MS1022x->msg_send_data_buffer[0] = cmd;
	return ms1022_spi_byte_buffer(MS1022x, MS1022x->msg_send_data_buffer, MS1022x->msg_read_data_buffer, 1);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 读取状态寄存器的值
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint16_t ms1022_spi_read_state(MS1022_HandleType* MS1022x)
{
	uint16_t _return = OK_0;
	MS1022x->msg_send_data_buffer[0] = MS1022_CMD_READ_STATE| MS1022_READ_ADDR_MASK;
	MS1022x->msg_send_data_buffer[1] = 0xFF;
	MS1022x->msg_send_data_buffer[2] = 0xFF;
	ms1022_spi_byte_buffer(MS1022x, MS1022x->msg_send_data_buffer, MS1022x->msg_read_data_buffer, 3);
	//---解析状态寄存器的值
	_return = MS1022x->msg_read_data_buffer[1];
	_return = (_return << 8) + MS1022x->msg_read_data_buffer[2];
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 读取脉冲宽度测量标志寄存器,固定浮点数，其中 1 位为整数
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_read_pw1st(MS1022_HandleType* MS1022x,uint8_t isup)
{
	uint8_t _return = OK_0;
	MS1022x->msg_send_data_buffer[0] = MS1022_CMD_READ_PW1ST | MS1022_READ_ADDR_MASK;
	MS1022x->msg_send_data_buffer[1] = 0xFF;
	_return=ms1022_spi_byte_buffer(MS1022x, MS1022x->msg_send_data_buffer, MS1022x->msg_read_data_buffer, 2);
	//---计算小数部分
	if (isup!=0)
	{
		MS1022x->msg_water_tof.msg_up_rssi = MS1022x->msg_read_data_buffer[1] & 0x7f;
		MS1022x->msg_water_tof.msg_up_rssi /= 128.0f;
		//---获取整数部分
		if ((MS1022x->msg_read_data_buffer[1] & 0x80) != 0)
		{
			MS1022x->msg_water_tof.msg_up_rssi += 1.0f;
		}
	}
	else
	{
		MS1022x->msg_water_tof.msg_down_rssi = MS1022x->msg_read_data_buffer[1] & 0x7f;
		MS1022x->msg_water_tof.msg_down_rssi /= 128.0f;
		//---获取整数部分
		if ((MS1022x->msg_read_data_buffer[1] & 0x80) != 0)
		{
			MS1022x->msg_water_tof.msg_down_rssi += 1.0f;
		}
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 通信测试函数
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_comm_test(MS1022_HandleType* MS1022x)
{
	MS1022x->msg_send_data_buffer[0] = MS1022_CMD_COMM_TEST | MS1022_READ_ADDR_MASK;
	MS1022x->msg_send_data_buffer[1] = 0xFF;
	return ms1022_spi_byte_buffer(MS1022x, MS1022x->msg_send_data_buffer, MS1022x->msg_read_data_buffer, 2);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 关闭主时钟，降低功耗
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_fosc_disable(MS1022_HandleType* MS1022x)
{
	//---关闭晶振
	return ms1022_spi_send_reg(MS1022x, 0, 0x0383E810);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 打开主时钟
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_fosc_enable(MS1022_HandleType* MS1022x)
{
	//---开启晶振
	return ms1022_spi_send_reg(MS1022x, 0, 0xF387E810);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 初始化配置
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_config_init(MS1022_HandleType* MS1022x)
{
	ms1022_spi_send_cmd(MS1022_TASK_ONE, MS1022_CMD_POWER_ON_RESET);
	//ms1022_spi_send_cmd(MS1022_TASK_ONE, MS1022_CMD_POWER_ON_RESET);
	////---等待数据稳定
	//delay_task_us(800);
	////--配置MS1022配置寄存器0 
	//ms1022_spi_send_reg(MS1022x, 0, 0xF387E810);
	////--配置MS1022配置寄存器1                 
	//ms1022_spi_send_reg(MS1022x, 1, 0x21444012);     
	////---配置MS1022配置寄存器6【模拟模式】            
	//ms1022_spi_send_reg(MS1022x, 6, 0xCEC06006);
	////---配置MS1022配置寄存器6【数字模式】
	////ms1022_spi_send_reg(MS1022x,6,0x4EC06006);               

	////---配置MS1022配置寄存器2
	//ms1022_spi_send_reg(MS1022x, 2, 0xA01F1402);    
	////---配置MS1022配置寄存器3              
	//ms1022_spi_send_reg(MS1022x, 3, 0x08000003);                 
	////---配置MS1022配置寄存器4
	//ms1022_spi_send_reg(MS1022x, 4, 0x20000004);               
	////---配置MS1022配置寄存器5【下游模式】
	//ms1022_spi_send_reg(MS1022x, 5, 0x50000005);  
	//return OK_0;
	//---获取进水口和出水口的温度，并计算超声波在水中的传播的速度
	return ms1022_spi_read_start_temperature(MS1022x);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 线性插值计算
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
float linear_interpolation(float xl1, float xh2, float yl1, float yh2, float xnew)
{
	float xratio=0.0f, xrange=0.0f, yrange = 0.0f, _return = 0.0f;
	xrange = (xh2 - xl1);
	yrange = (yh2 - yl1);
	xratio = (xnew - xl1) / xrange;
	_return = yl1 + yrange*xratio;
	return (_return);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 通过PT电阻计算温度值
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
float calculate_temperature(float ptres)
{
	float _return = 0.0f;
	int xp = 0,yp = 0;
	//---查找X维度坐标信息
	for (xp = 0; xp < 101; xp++)
	{
		if (ptres <= g_pt_table[xp][0])
		{
			break;
		}
	}
	xp--;
	//---查找Y维度坐标信息
	for (yp = 0; yp < 10; yp++)
	{
		if (ptres <= g_pt_table[xp][yp])
		{
			break;
		}
	}
	yp--;
	//---返回线性插值的结算结果
	return linear_interpolation(g_pt_table[xp][yp],
		g_pt_table[xp][yp + 1],
		(xp + (yp*0.1f)),
		(xp + ((yp + 1)*0.1f)),
		ptres);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 计算超声波在水中的传播速度
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
float calcate_sound_speed(float temperature)
{
	//---温度的整数部分
	uint16_t temp_integer = (uint16_t)temperature;
	//---返回经过插值计算的结果
	return linear_interpolation(temp_integer,
		temp_integer + 1,
		g_sound_speed_table[temp_integer],
		g_sound_speed_table[temp_integer + 1],
		temperature);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 根据温度计算焓值
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
float calculate_enthalpy(float temperature)
{
	//---温度的整数部分
	uint16_t temp_integer = (uint16_t)temperature;
	//---返回经过插值计算的结果
	return linear_interpolation(temp_integer,
		temp_integer + 1,
		g_enthalpy_table[temp_integer],
		g_enthalpy_table[temp_integer + 1],
		temperature);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 计算水的密度
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
float calculate_density(float temperature)
{
	//---温度的整数部分
	uint16_t temp_integer = (uint16_t)temperature;
	//---返回经过插值计算的结果
	return linear_interpolation(temp_integer,
		temp_integer + 1,
		g_density_table[temp_integer],
		g_density_table[temp_integer + 1],
		temperature);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 计算当前水温下的粘度
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
float calculate_viscosity(float temperature)
{
	//---温度的整数部分
	uint16_t temp_integer = (uint16_t)temperature;
	//---返回经过插值计算的结果
	return linear_interpolation(temp_integer,
		temp_integer + 1,
		g_viscosity_table[temp_integer],
		g_viscosity_table[temp_integer + 1],
		temperature);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 计算通道的PT电阻值，用于换算为温度值
//////输入参	数:
//////输出参	数:
//////说		明: 8次采样，70ms
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_read_start_temperature(MS1022_HandleType* MS1022x)
{
	uint8_t _return = OK_0;
	uint8_t sample_index = 0;
	uint16_t sample_state = 0;
	uint16_t sample_integer = 0;
	float sample_temp[4] = { 0.0f };
	float samp_res[2] = { 0.0f };
	//---进水口PT电阻
	float samp_pt_in[MS1022_TEMPERATURE_SAMPLE_MAX_NUM] = { 0.0f };
	//---出水口PT电阻
	float samp_pt_out[MS1022_TEMPERATURE_SAMPLE_MAX_NUM] = { 0.0f };
	//---打开参考时钟
	MS1022_32KHZ_CLOCK_ENABLE();
	//---延时等待时钟稳定
	NOP(); NOP(); NOP(); NOP();
	NOP(); NOP(); NOP(); NOP();
	NOP(); NOP(); NOP(); NOP();
	NOP(); NOP(); NOP(); NOP();
	//---开启晶振
	ms1022_spi_fosc_enable(MS1022x);
	//---上电复位
	ms1022_spi_send_cmd(MS1022x,MS1022_CMD_POWER_ON_RESET);
	//---等待时钟稳定和数据稳定
	delay_task_us(800);
	//---初始化温度测量配置
	ms1022_spi_send_reg(MS1022x,0, 0xF387E810);
	ms1022_spi_send_reg(MS1022x,1, 0x21444012);
	ms1022_spi_send_reg(MS1022x,6, 0xCEC06006);
	//---清楚状态信息
	ms1022_spi_int_flag_clear(MS1022x);
	//-->>>循环测试多组温度值，计算平均值---开始
	for (sample_index=0;sample_index<MS1022_TEMPERATURE_SAMPLE_MAX_NUM;sample_index++)
	{
		//---发送初始化命令
		ms1022_spi_send_cmd(MS1022x, MS1022_CMD_INIT);
		//---启动温度测量
		ms1022_spi_send_cmd(MS1022x, MS1022_CMD_START_TEMP);
		//---等待中断信号
		_return=ms1022_spi_int_flag_wait(MS1022x);
		//---清除中断标识
		ms1022_spi_int_flag_clear(MS1022x);
		//---判断是否获取到中断标识
		if (_return==OK_0)
		{
			//---解析读取状态寄存器的值
			sample_state=ms1022_spi_read_state(MS1022x);
			//---判断温度状态信息
			if ((sample_state&MS1022_STATE_TEMPERATURE_MASK)!=0)
			{
				if ((sample_state&MS1022_STATE_TEMPERATURE_OPEN)!=0)
				{
					//---温度传感器开路
					_return = ERROR_2;
				}
				else
				{
					//---温度传感器短路
					_return = ERROR_3;
				}
				break;
			}
			else
			{
				//---通道0的电阻值
				ms1022_spi_read_reg(MS1022x, 0);
				//---计算整数部分
				sample_integer = MS1022x->msg_read_data_buffer[1];
				sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
				//---计算小数部分
				sample_temp[0] = MS1022x->msg_read_data_buffer[3];
				sample_temp[0] = ((uint16_t)sample_temp[0] << 8) + MS1022x->msg_read_data_buffer[4];
				//---计算实际值
				sample_temp[0] = sample_temp[0] / 65536.0f + sample_integer;
				//---通道1的电阻值
				ms1022_spi_read_reg(MS1022x, 1);
				//---计算整数部分
				sample_integer = MS1022x->msg_read_data_buffer[1];
				sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
				//---计算小数部分
				sample_temp[1] = MS1022x->msg_read_data_buffer[3];
				sample_temp[1] = ((uint16_t)sample_temp[1] << 8) + MS1022x->msg_read_data_buffer[4];
				//---计算实际值
				sample_temp[1] = sample_temp[1] / 65536.0f + sample_integer;
				//---通道2的电阻值
				ms1022_spi_read_reg(MS1022x, 2);
				//---计算整数部分
				sample_integer = MS1022x->msg_read_data_buffer[1];
				sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
				//---计算小数部分
				sample_temp[2] = MS1022x->msg_read_data_buffer[3];
				sample_temp[2] = ((uint16_t)sample_temp[2] << 8) + MS1022x->msg_read_data_buffer[4];
				//---计算实际值
				sample_temp[2] = sample_temp[2] / 65536.0f + sample_integer;
				//---通道3的电阻值
				ms1022_spi_read_reg(MS1022x, 3);
				//---计算整数部分
				sample_integer = MS1022x->msg_read_data_buffer[1];
				sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
				//---计算小数部分
				sample_temp[3] = MS1022x->msg_read_data_buffer[3];
				sample_temp[3] = ((uint16_t)sample_temp[3] << 8) + MS1022x->msg_read_data_buffer[4];
				//---计算实际值
				sample_temp[3] = sample_temp[0] / 65536.0f + sample_integer;

				//---计算进水PT电阻的阻值
				samp_res[0] = sample_temp[0]/ sample_temp[2];
				samp_res[0] *= MS1022_PT_RTD_REF1;

				samp_res[1] = sample_temp[0]/ sample_temp[3];
				samp_res[1] *= MS1022_PT_RTD_REF2;

				//---保存进水PT电阻值
				samp_pt_in[sample_index] = (samp_res[0] + samp_res[1]) / 2.0f;

				//---计算出水PT电阻的阻值
				samp_res[0] = sample_temp[1] / sample_temp[2];
				samp_res[0] *= MS1022_PT_RTD_REF1;

				samp_res[1] = sample_temp[1] / sample_temp[3];
				samp_res[1] *= MS1022_PT_RTD_REF2;

				//---保存出水PT电阻值
				samp_pt_out[sample_index] = (samp_res[0] + samp_res[1]) / 2.0f;
			}
		}
		else
		{
			//---判断温度采集状态
			_return = ERROR_1;
			break;
		}
	}
	//---关闭晶振
	ms1022_spi_fosc_disable(MS1022x);
	//---上电复位设备
	ms1022_spi_send_cmd(MS1022x, MS1022_CMD_POWER_ON_RESET);
	//---关闭参考时钟
	MS1022_32KHZ_CLOCK_DISABLE();
	//---判断阻值是否获取完成
	if (_return==OK_0)
	{
		//---升序排列进水温度
		asc_sort_float(samp_pt_in, MS1022_TEMPERATURE_SAMPLE_MAX_NUM);
		//---升序排列出水温度
		asc_sort_float(samp_pt_out, MS1022_TEMPERATURE_SAMPLE_MAX_NUM);
		//---计算进水PT电阻值的平均值，去掉最大和最小的各2个
		samp_res[0] = calc_avg_float(samp_pt_in + 2, MS1022_TEMPERATURE_SAMPLE_MAX_NUM - 4);
		//---计算出水PT电阻的平均值，去掉最大和最小的各2个
		samp_res[1] = calc_avg_float(samp_pt_out + 2, MS1022_TEMPERATURE_SAMPLE_MAX_NUM - 4);
		//---根据PT电阻值计算出水温度值
		MS1022x->msg_water_temperature.msg_out_temp = calculate_temperature(samp_res[0]);
		//---根据温度系数换算为实际出水温度
		MS1022x->msg_water_temperature.msg_out_temp *= MS1022x->msg_water_temperature.msg_out_temp_factor;
		//---根据PT电阻值计算进水温度值
		MS1022x->msg_water_temperature.msg_in_temp = calculate_temperature(samp_res[1]); 
		//---根据温度系数换算为实际进水温度
		MS1022x->msg_water_temperature.msg_in_temp *= MS1022x->msg_water_temperature.msg_in_temp_factor;
		//---计算温差
		MS1022x->msg_water_temperature.msg_diff_temp = ABS_SUB(MS1022x->msg_water_temperature.msg_in_temp, MS1022x->msg_water_temperature.msg_out_temp);
		//---判断温差是不是负数
		if (MS1022x->msg_water_temperature.msg_in_temp<MS1022x->msg_water_temperature.msg_out_temp)
		{
			//---温差为负数
			MS1022x->msg_water_temperature.msg_positive_mode = 1;
		}
		else
		{
			//---温差为正数
			MS1022x->msg_water_temperature.msg_positive_mode = 0;
		}
		//---计算在水中的传播速度
		MS1022x->msg_water_tof.msg_sound_speed = calcate_sound_speed(MS1022x->msg_water_temperature.msg_in_temp);

#if (MODULE_LOG_MS1022>0)
		LOG_VA_ARGS("PT_IN:%.3f,PT_OUT:%.3f,PT_DIF:%.3f,SPEED:%.3f\r\n",
			MS1022x->msg_water_temperature.msg_in_temp, 
			MS1022x->msg_water_temperature.msg_out_temp,
			(MS1022x->msg_water_temperature.msg_positive_mode==0)?(MS1022x->msg_water_temperature.msg_diff_temp):(MS1022x->msg_water_temperature.msg_diff_temp*(-1)),
			MS1022x->msg_water_tof.msg_sound_speed);
#endif
	}
	//--<<<循环测试多组温度值，计算平均值---结束
	//---水温采集状态
	MS1022x->msg_water_temperature.msg_state = _return;
	
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 计算通道的PT电阻值，用于换算为温度值
//////输入参	数:
//////输出参	数:
//////说		明: 8次采样，70ms
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_read_start_temperature_restart(MS1022_HandleType* MS1022x)
{
	uint8_t _return = OK_0;
	uint8_t sample_index = 0;
	uint16_t sample_state = 0;
	uint16_t sample_integer = 0;
	float sample_temp[4] = { 0.0f };
	float samp_res[2] = { 0.0f };
	//---进水口PT电阻
	float samp_pt_in[MS1022_TEMPERATURE_SAMPLE_MAX_NUM] = { 0.0f };
	//---出水口PT电阻
	float samp_pt_out[MS1022_TEMPERATURE_SAMPLE_MAX_NUM] = { 0.0f };
	//---打开参考时钟
	MS1022_32KHZ_CLOCK_ENABLE();
	//---延时等待时钟稳定
	NOP(); NOP(); NOP(); NOP();
	NOP(); NOP(); NOP(); NOP();
	NOP(); NOP(); NOP(); NOP();
	NOP(); NOP(); NOP(); NOP();
	//---开启晶振
	ms1022_spi_fosc_enable(MS1022x);
	//---上电复位
	ms1022_spi_send_cmd(MS1022x, MS1022_CMD_POWER_ON_RESET);
	//---等待时钟稳定和数据稳定
	delay_task_us(800);
	//---初始化温度测量配置
	ms1022_spi_send_reg(MS1022x, 0, 0xF387E810);
	ms1022_spi_send_reg(MS1022x, 1, 0x21444012);
	//---温度测量间隔是15ms
	ms1022_spi_send_reg(MS1022x, 6, 0xCEC06006);
	//---清楚中断标志
	ms1022_spi_int_flag_clear(MS1022x);
	//-->>>循环测试多组温度值，计算平均值---开始
	for (sample_index = 0; sample_index < MS1022_TEMPERATURE_SAMPLE_MAX_NUM; sample_index+=2)
	{
		//---发送初始化命令
		ms1022_spi_send_cmd(MS1022x, MS1022_CMD_INIT);
		//---启动温度测量
		ms1022_spi_send_cmd(MS1022x, MS1022_CMD_START_TEMP_RESTART);
		//---等待中断信号
		_return = ms1022_spi_int_flag_wait(MS1022x);
		//---清除中断标识
		ms1022_spi_int_flag_clear(MS1022x);
		//---判断是否获取到中断标识
		if (_return == OK_0)
		{

			//---第一次温度测量
			//---读取状态寄存器的值
			sample_state|=ms1022_spi_read_state(MS1022x);
			//---判断温度状态信息
			if ((sample_state&MS1022_STATE_TEMPERATURE_MASK) != 0)
			{
				if ((sample_state&MS1022_STATE_TEMPERATURE_OPEN) != 0)
				{
					//---温度传感器开路
					_return = ERROR_2;
				}
				else
				{
					//---温度传感器短路
					_return = ERROR_3;
				}
				break;
			}
			else
			{
				//---通道0的电阻值
				ms1022_spi_read_reg(MS1022x, 0);
				//---计算整数部分
				sample_integer = MS1022x->msg_read_data_buffer[1];
				sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
				//---计算小数部分
				sample_temp[0] = MS1022x->msg_read_data_buffer[3];
				sample_temp[0] = ((uint16_t)sample_temp[0] << 8) + MS1022x->msg_read_data_buffer[4];
				//---计算实际值
				sample_temp[0] = sample_temp[0] / 65536.0f + sample_integer;
				//---通道1的电阻值
				ms1022_spi_read_reg(MS1022x, 1);
				//---计算整数部分
				sample_integer = MS1022x->msg_read_data_buffer[1];
				sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
				//---计算小数部分
				sample_temp[1] = MS1022x->msg_read_data_buffer[3];
				sample_temp[1] = ((uint16_t)sample_temp[1] << 8) + MS1022x->msg_read_data_buffer[4];
				//---计算实际值
				sample_temp[1] = sample_temp[1] / 65536.0f + sample_integer;
				//---通道2的电阻值
				ms1022_spi_read_reg(MS1022x, 2);
				//---计算整数部分
				sample_integer = MS1022x->msg_read_data_buffer[1];
				sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
				//---计算小数部分
				sample_temp[2] = MS1022x->msg_read_data_buffer[3];
				sample_temp[2] = ((uint16_t)sample_temp[2] << 8) + MS1022x->msg_read_data_buffer[4];
				//---计算实际值
				sample_temp[2] = sample_temp[2] / 65536.0f + sample_integer;
				//---通道3的电阻值
				ms1022_spi_read_reg(MS1022x, 3);
				//---计算整数部分
				sample_integer = MS1022x->msg_read_data_buffer[1];
				sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
				//---计算小数部分
				sample_temp[3] = MS1022x->msg_read_data_buffer[3];
				sample_temp[3] = ((uint16_t)sample_temp[3] << 8) + MS1022x->msg_read_data_buffer[4];
				//---计算实际值
				sample_temp[3] = sample_temp[0] / 65536.0f + sample_integer;

				//---计算进水PT电阻的阻值
				samp_res[0] = sample_temp[0] / sample_temp[2];
				samp_res[0] *= MS1022_PT_RTD_REF1;

				samp_res[1] = sample_temp[0] / sample_temp[3];
				samp_res[1] *= MS1022_PT_RTD_REF2;

				//---保存进水PT电阻值
				samp_pt_in[sample_index] = (samp_res[0] + samp_res[1]) / 2.0f;

				//---计算出水PT电阻的阻值
				samp_res[0] = sample_temp[1] / sample_temp[2];
				samp_res[0] *= MS1022_PT_RTD_REF1;

				samp_res[1] = sample_temp[1] / sample_temp[3];
				samp_res[1] *= MS1022_PT_RTD_REF2;

				//---保存出水PT电阻值
				samp_pt_out[sample_index] = (samp_res[0] + samp_res[1]) / 2.0f;
			}

			//---第二次温度测量
			//---发送初始化命令
			ms1022_spi_send_cmd(MS1022x, MS1022_CMD_INIT);
			//---等待中断信号
			_return = ms1022_spi_int_flag_wait(MS1022x);
			//---清除中断标识
			ms1022_spi_int_flag_clear(MS1022x);
			//---解析读取状态寄存器的值
			sample_state = ms1022_spi_read_state(MS1022x);
			//---通道0的电阻值
			ms1022_spi_read_reg(MS1022x, 0);
			//---计算整数部分
			sample_integer = MS1022x->msg_read_data_buffer[1];
			sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
			//---计算小数部分
			sample_temp[0] = MS1022x->msg_read_data_buffer[3];
			sample_temp[0] = ((uint16_t)sample_temp[0] << 8) + MS1022x->msg_read_data_buffer[4];
			//---计算实际值
			sample_temp[0] = sample_temp[0] / 65536.0f + sample_integer;
			//---通道1的电阻值
			ms1022_spi_read_reg(MS1022x, 1);
			//---计算整数部分
			sample_integer = MS1022x->msg_read_data_buffer[1];
			sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
			//---计算小数部分
			sample_temp[1] = MS1022x->msg_read_data_buffer[3];
			sample_temp[1] = ((uint16_t)sample_temp[1] << 8) + MS1022x->msg_read_data_buffer[4];
			//---计算实际值
			sample_temp[1] = sample_temp[1] / 65536.0f + sample_integer;
			//---通道2的电阻值
			ms1022_spi_read_reg(MS1022x, 2);
			//---计算整数部分
			sample_integer = MS1022x->msg_read_data_buffer[1];
			sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
			//---计算小数部分
			sample_temp[2] = MS1022x->msg_read_data_buffer[3];
			sample_temp[2] = ((uint16_t)sample_temp[2] << 8) + MS1022x->msg_read_data_buffer[4];
			//---计算实际值
			sample_temp[2] = sample_temp[2] / 65536.0f + sample_integer;
			//---通道3的电阻值
			ms1022_spi_read_reg(MS1022x, 3);
			//---计算整数部分
			sample_integer = MS1022x->msg_read_data_buffer[1];
			sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
			//---计算小数部分
			sample_temp[3] = MS1022x->msg_read_data_buffer[3];
			sample_temp[3] = ((uint16_t)sample_temp[3] << 8) + MS1022x->msg_read_data_buffer[4];
			//---计算实际值
			sample_temp[3] = sample_temp[0] / 65536.0f + sample_integer;

			//---计算进水PT电阻的阻值
			samp_res[0] = sample_temp[0] / sample_temp[2];
			samp_res[0] *= MS1022_PT_RTD_REF1;

			samp_res[1] = sample_temp[0] / sample_temp[3];
			samp_res[1] *= MS1022_PT_RTD_REF2;

			//---保存进水PT电阻值
			samp_pt_in[sample_index + 1] = (samp_res[0] + samp_res[1]) / 2.0f;

			//---计算出水PT电阻的阻值
			samp_res[0] = sample_temp[1] / sample_temp[2];
			samp_res[0] *= MS1022_PT_RTD_REF1;

			samp_res[1] = sample_temp[1] / sample_temp[3];
			samp_res[1] *= MS1022_PT_RTD_REF2;

			//---保存出水PT电阻值
			samp_pt_out[sample_index + 1] = (samp_res[0] + samp_res[1]) / 2.0f;
		}
		else
		{
			//---判断温度采集状态
			_return = ERROR_1;
			break;
		}
	}
	//---关闭晶振
	ms1022_spi_fosc_disable(MS1022x);
	//---上电复位设备
	ms1022_spi_send_cmd(MS1022x, MS1022_CMD_POWER_ON_RESET);
	//---关闭参考时钟
	MS1022_32KHZ_CLOCK_DISABLE();
	//---判断阻值是否获取完成
	if (_return == OK_0)
	{
		//---升序排列进水温度
		asc_sort_float(samp_pt_in, MS1022_TEMPERATURE_SAMPLE_MAX_NUM);
		//---升序排列出水温度
		asc_sort_float(samp_pt_out, MS1022_TEMPERATURE_SAMPLE_MAX_NUM);
		//---计算进水PT电阻值的平均值，去掉最大和最小的各2个
		samp_res[0] = calc_avg_float(samp_pt_in + 2, MS1022_TEMPERATURE_SAMPLE_MAX_NUM - 4);
		//---计算出水PT电阻的平均值，去掉最大和最小的各2个
		samp_res[1] = calc_avg_float(samp_pt_out + 2, MS1022_TEMPERATURE_SAMPLE_MAX_NUM - 4);
		//---根据PT电阻值计算出水温度值
		MS1022x->msg_water_temperature.msg_out_temp = calculate_temperature(samp_res[0]);
		//---根据温度系数换算为实际出水温度
		MS1022x->msg_water_temperature.msg_out_temp *= MS1022x->msg_water_temperature.msg_out_temp_factor;
		//---根据PT电阻值计算进水温度值
		MS1022x->msg_water_temperature.msg_in_temp = calculate_temperature(samp_res[1]);
		//---根据温度系数换算为实际进水温度
		MS1022x->msg_water_temperature.msg_in_temp *= MS1022x->msg_water_temperature.msg_in_temp_factor;
		//---计算温差
		MS1022x->msg_water_temperature.msg_diff_temp = ABS_SUB(MS1022x->msg_water_temperature.msg_in_temp, MS1022x->msg_water_temperature.msg_out_temp);
		//---判断温差是不是负数
		if (MS1022x->msg_water_temperature.msg_in_temp < MS1022x->msg_water_temperature.msg_out_temp)
		{
			//---温差为负数
			MS1022x->msg_water_temperature.msg_positive_mode = 1;
		}
		else
		{
			//---温差为正数
			MS1022x->msg_water_temperature.msg_positive_mode = 0;
		}
		//---计算在水中的传播速度
		MS1022x->msg_water_tof.msg_sound_speed = calcate_sound_speed(MS1022x->msg_water_temperature.msg_in_temp);

#if (MODULE_LOG_MS1022>0)
		LOG_VA_ARGS("PT_IN:%.3f,PT_OUT:%.3f,PT_DIF:%.3f,SPEED:%.3f\r\n",
			MS1022x->msg_water_temperature.msg_in_temp,
			MS1022x->msg_water_temperature.msg_out_temp,
			(MS1022x->msg_water_temperature.msg_positive_mode == 0) ? (MS1022x->msg_water_temperature.msg_diff_temp) : (MS1022x->msg_water_temperature.msg_diff_temp*(-1)),
			MS1022x->msg_water_tof.msg_sound_speed);
#endif
	}
	//--<<<循环测试多组温度值，计算平均值---结束
	//---水温采集状态
	MS1022x->msg_water_temperature.msg_state = _return;

	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 校准时钟获取校正因子
//////输入参	数:
//////输出参	数:
//////说		明: 校正因子和CLKHSDIV配置以及ANZ_PER_CALRES有关，参考数据手册46页
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_calibration_resonator(MS1022_HandleType* MS1022x)
{
	uint8_t _return = OK_0;
	uint16_t temp_integer = 0;
	//---开启晶振
	//ms1022_spi_fosc_enable(MS1022x);
	//---上电复位,复位之后需要进行配置初始化
	//ms1022_spi_send_cmd(MS1022x, MS1022_CMD_POWER_ON_RESET);
	//---等待时钟稳定和数据稳定
	//delay_task_us(800);
	//---清除中断标识
	ms1022_spi_int_flag_clear(MS1022x);
	//---发送初始化命令
	ms1022_spi_send_cmd(MS1022x, MS1022_CMD_INIT);
	//---启动温度测量
	ms1022_spi_send_cmd(MS1022x, MS1022_CMD_START_CAL_RESONATOR);
	//---等待中断信号
	_return = ms1022_spi_int_flag_wait(MS1022x);
	//---清除中断标识
	ms1022_spi_int_flag_clear(MS1022x);
	//---判断中断信号的结果
	if (_return==OK_0)
	{
		//---读取结果寄存器的值
		ms1022_spi_read_reg(MS1022x, 0);
		//---计算整数部分
		temp_integer = MS1022x->msg_read_data_buffer[1];
		temp_integer = (temp_integer << 8) + MS1022x->msg_read_data_buffer[2];
		//---计算小数部分
		MS1022x->msg_water_tof.msg_time_factor = MS1022x->msg_read_data_buffer[3];
		MS1022x->msg_water_tof.msg_time_factor = ((uint16_t)MS1022x->msg_water_tof.msg_time_factor << 8) + MS1022x->msg_read_data_buffer[4];
		//---换算为时钟因子
		MS1022x->msg_water_tof.msg_time_factor =(MS1022x->msg_water_tof.msg_time_factor /65536.0f)+ temp_integer;
		//---计算实际时间
		MS1022x->msg_water_tof.msg_time_factor *= MS1022_HSE_CLOCK_MIN_WIDTH;
		//---计算时钟校准因子
		MS1022x->msg_water_tof.msg_time_factor = 244.140625f / MS1022x->msg_water_tof.msg_time_factor;
	}
	else
	{
		MS1022x->msg_water_tof.msg_time_factor = 1.0f;
	}
#if (MODULE_LOG_MS1022>0)
	LOG_VA_ARGS("TOF_RATIO:%.3f\r\n",
		MS1022x->msg_water_tof.msg_time_factor);
#endif
	//---开启晶振
	//ms1022_spi_fosc_disable(MS1022x);
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 设置屏蔽窗口的时间
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint32_t  ms1022_spi_calculate_delval(MS1022_HandleType* MS1022x,float us)
{
	uint32_t _return = 0;
	us /= MS1022_HSE_CLOCK_MIN_WIDTH;
	us /= MS1022_CLKHSDIV_PRE;
	//---计算整数值
	us *= 32;
	_return= (uint32_t)us;
	return (_return << 8);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 设置第一波模式的偏置电压
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint32_t  ms1022_spi_calculate_offset(MS1022_HandleType* MS1022x, uint32_t offsetmv)
{
	uint32_t _return = 0;
	switch (offsetmv)
	{
		case MS1022_OFFSET_MV_P0	:
		case MS1022_OFFSET_MV_P1	:
		case MS1022_OFFSET_MV_P2	:
		case MS1022_OFFSET_MV_P3	:
		case MS1022_OFFSET_MV_P4	:
		case MS1022_OFFSET_MV_P5	:
		case MS1022_OFFSET_MV_P6	:
		case MS1022_OFFSET_MV_P7	:
		case MS1022_OFFSET_MV_P8	:
		case MS1022_OFFSET_MV_P9	:
		case MS1022_OFFSET_MV_P10  :
		case MS1022_OFFSET_MV_P11  :
		case MS1022_OFFSET_MV_P12  :
		case MS1022_OFFSET_MV_P13  :
		case MS1022_OFFSET_MV_P14  :
		case MS1022_OFFSET_MV_P15  :
		case MS1022_OFFSET_MV_N1	:
		case MS1022_OFFSET_MV_N2	:
		case MS1022_OFFSET_MV_N3	:
		case MS1022_OFFSET_MV_N4	:
		case MS1022_OFFSET_MV_N5	:
		case MS1022_OFFSET_MV_N6	:
		case MS1022_OFFSET_MV_N7	:
		case MS1022_OFFSET_MV_N8	:
		case MS1022_OFFSET_MV_N9	:
		case MS1022_OFFSET_MV_N10  :
		case MS1022_OFFSET_MV_N11  :
		case MS1022_OFFSET_MV_N12  :
		case MS1022_OFFSET_MV_N13  :
		case MS1022_OFFSET_MV_N14  :
		case MS1022_OFFSET_MV_N15  :
		case MS1022_OFFSET_MV_N16 :
		{
			_return = offsetmv;
			break;
		}
		default:
		{
			_return = MS1022_OFFSET_MV_P10;
			break; 
		}
	}
	return _return;
}

float sample_temp[4] = { 0.0f };

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: TDC测试前的猪呢比
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_read_start_tof_pre(MS1022_HandleType* MS1022x,uint32_t *pstate, uint32_t offsetmv)
{
	uint8_t _return = OK_0;
	uint16_t sample_state = 0;
	uint16_t sample_integer = 0;
	uint32_t temp_reg = 0;
	float samp_res[2] = { 0.0f };
	//---计算偏置电压的设置
	temp_reg = ms1022_spi_calculate_offset(MS1022x, offsetmv);
	temp_reg |= 0x20004004;
	ms1022_spi_send_reg(MS1022x, 4, temp_reg);
	ms1022_spi_send_reg(MS1022x, 5, 0x30000005);
	//---清楚中断标志位
	ms1022_spi_int_flag_clear(MS1022x);
	//--->>>读取上游时差
	//---初始化设备
	ms1022_spi_send_cmd(MS1022x, MS1022_CMD_INIT);
	//---启动时差测量
	//---上电复位设备
	ms1022_spi_send_cmd(MS1022x, MS1022_CMD_START_TOF);
	//---等待测量完成
	_return = ms1022_spi_int_flag_wait(MS1022x);
	//---清楚状态信息
	ms1022_spi_int_flag_clear(MS1022x);
	//---判断中断标志
	if (_return == OK_0)
	{
		//---解析读取状态寄存器的值
		sample_state = ms1022_spi_read_state(MS1022x);
		//---判断温度状态信息
		if ((sample_state&MS1022_STATE_TDC_MASK) != 0)
		{
			if ((sample_state&MS1022_STATE_PRECOUNTER_TIME_OUT) != 0)
			{
				//---14位粗值计数器溢出
				_return = ERROR_2;
			}
			else
			{
				//---TDC测量单元溢出
				_return = ERROR_3;
			}
		}
		//---如果状态寄存器为0
		if ((sample_state&0x03)!=0x03)
		{
			//---3个结果寄存器数据获取失败
			_return = ERROR_4;
		}
		//---保存上游的状态寄存器值
		(*pstate) = sample_state;
		//---读取结果寄存器0
		ms1022_spi_read_reg(MS1022x, 0);
		//---计算整数部分
		sample_integer = MS1022x->msg_read_data_buffer[1];
		sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
		//---判断是否是最大值
		if (sample_integer == 0xFFFF)
		{
			_return = ERROR_5;
		}
		//---计算小数部分
		sample_temp[0] = MS1022x->msg_read_data_buffer[3];
		sample_temp[0] = ((uint16_t)sample_temp[0] << 8) + MS1022x->msg_read_data_buffer[4];
		//---判断是否是最大值
		if (((uint16_t)sample_temp[0]) == 0xFFFF)
		{
			_return = ERROR_6;
		}
		//---计算实际值
		sample_temp[0] = sample_temp[0] / 65536.0f + sample_integer;
		//---读取结果寄存器1
		ms1022_spi_read_reg(MS1022x, 1);
		//---计算整数部分
		sample_integer = MS1022x->msg_read_data_buffer[1];
		sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
		//---计算小数部分
		sample_temp[1] = MS1022x->msg_read_data_buffer[3];
		sample_temp[1] = ((uint16_t)sample_temp[1] << 8) + MS1022x->msg_read_data_buffer[4];
		//---计算实际值
		sample_temp[1] = sample_temp[1] / 65536.0f + sample_integer;
		//---读取结果寄存器2
		ms1022_spi_read_reg(MS1022x, 2);
		//---计算整数部分
		sample_integer = MS1022x->msg_read_data_buffer[1];
		sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
		//---计算小数部分
		sample_temp[2] = MS1022x->msg_read_data_buffer[3];
		sample_temp[2] = ((uint16_t)sample_temp[2] << 8) + MS1022x->msg_read_data_buffer[4];
		//---计算实际值
		sample_temp[2] = sample_temp[2] / 65536.0f + sample_integer;
		//---读取结果寄存器3
		ms1022_spi_read_reg(MS1022x, 3);
		//---计算整数部分
		sample_integer = MS1022x->msg_read_data_buffer[1];
		sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
		//---计算小数部分
		sample_temp[3] = MS1022x->msg_read_data_buffer[3];
		sample_temp[3] = ((uint16_t)sample_temp[3] << 8) + MS1022x->msg_read_data_buffer[4];
		//---计算实际值
		sample_temp[3] = sample_temp[0] / 65536.0f + sample_integer;
		//---脉冲宽度检查信号
		ms1022_spi_read_pw1st(MS1022x,1);
		//---判断结果是否有效
		if (((sample_temp[3] / sample_temp[0]) < 2.8f) ||
			((sample_temp[3] / sample_temp[1]) < 2.8f) ||
			((sample_temp[3] / sample_temp[2]) < 2.8f))
		{
			_return = ERROR_7;
		}
		//---调试记录时间信息
#if (MODULE_LOG_MS1022>0)
		LOG_VA_ARGS("UP_TEST:T0:%.3f,T1:%.3f,T2:%.3f,T3:%.3f,RSSI:%.3f\r\n",
			sample_temp[0] * MS1022_HSE_CLOCK_MIN_WIDTH,
			sample_temp[1] * MS1022_HSE_CLOCK_MIN_WIDTH,
			sample_temp[2] * MS1022_HSE_CLOCK_MIN_WIDTH,
			sample_temp[3] * MS1022_HSE_CLOCK_MIN_WIDTH,
			MS1022x->msg_water_tof.msg_up_rssi);
#endif
	}
	//---<<<读取上游时差
	//--->>>读取下游时差
	//---设置偏置电压
	//ms1022_spi_send_reg(MS1022x, 4, temp_reg);
	ms1022_spi_send_reg(MS1022x, 5, 0x50000005);
	//---初始化设备
	ms1022_spi_send_cmd(MS1022x, MS1022_CMD_INIT);
	//---启动时差测量
	//---上电复位设备
	ms1022_spi_send_cmd(MS1022x, MS1022_CMD_START_TOF);
	//---等待测量完成
	_return = ms1022_spi_int_flag_wait(MS1022x);
	//---清楚中断标志位
	ms1022_spi_int_flag_clear(MS1022x);
	//---判断中断标志
	if (_return == OK_0)
	{
		//---解析读取状态寄存器的值
		sample_state = ms1022_spi_read_state(MS1022x);
		//---判断温度状态信息
		if ((sample_state&MS1022_STATE_TDC_MASK) != 0)
		{
			if ((sample_state&MS1022_STATE_PRECOUNTER_TIME_OUT) != 0)
			{
				//---14位粗值计数器溢出
				_return = ERROR_2+0x80;
			}
			else
			{
				//---TDC测量单元溢出
				_return = ERROR_3 + 0x80;
			}
		}
		//---如果状态寄存器为0
		if ((sample_state & 0x03) != 0x03)
		{
			//---3个结果寄存器数据获取失败
			_return = ERROR_4 + 0x80;
		}
		//---保存下游的状态寄存器值
		(*pstate) =((*pstate)<<16)|sample_state;
		//---读取结果寄存器0
		ms1022_spi_read_reg(MS1022x, 0);
		//---计算整数部分
		sample_integer = MS1022x->msg_read_data_buffer[1];
		sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
		//---判断是否是最大值
		if (sample_integer==0xFFFF)
		{
			_return = ERROR_5+0x80;
		}
		//---计算小数部分
		sample_temp[0] = MS1022x->msg_read_data_buffer[3];
		sample_temp[0] = ((uint16_t)sample_temp[0] << 8) + MS1022x->msg_read_data_buffer[4];
		//---判断是否是最大值
		if (((uint16_t)sample_temp[0]) == 0xFFFF)
		{
			_return = ERROR_6+0x80;
		}
		//---计算实际值
		sample_temp[0] = sample_temp[0] / 65536.0f + sample_integer;
		//---读取结果寄存器1
		ms1022_spi_read_reg(MS1022x, 1);
		//---计算整数部分
		sample_integer = MS1022x->msg_read_data_buffer[1];
		sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
		//---计算小数部分
		sample_temp[1] = MS1022x->msg_read_data_buffer[3];
		sample_temp[1] = ((uint16_t)sample_temp[1] << 8) + MS1022x->msg_read_data_buffer[4];
		//---计算实际值
		sample_temp[1] = sample_temp[1] / 65536.0f + sample_integer;
		//---读取结果寄存器2
		ms1022_spi_read_reg(MS1022x, 2);
		//---计算整数部分
		sample_integer = MS1022x->msg_read_data_buffer[1];
		sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
		//---计算小数部分
		sample_temp[2] = MS1022x->msg_read_data_buffer[3];
		sample_temp[2] = ((uint16_t)sample_temp[2] << 8) + MS1022x->msg_read_data_buffer[4];
		//---计算实际值
		sample_temp[2] = sample_temp[2] / 65536.0f + sample_integer;
		//---读取结果寄存器3
		ms1022_spi_read_reg(MS1022x, 3);
		//---计算整数部分
		sample_integer = MS1022x->msg_read_data_buffer[1];
		sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
		//---计算小数部分
		sample_temp[3] = MS1022x->msg_read_data_buffer[3];
		sample_temp[3] = ((uint16_t)sample_temp[3] << 8) + MS1022x->msg_read_data_buffer[4];
		//---计算实际值
		sample_temp[3] = sample_temp[0] / 65536.0f + sample_integer;
		//---脉冲宽度检查信号
		ms1022_spi_read_pw1st(MS1022x,0);
		//---判断结果是否有效
		if (((sample_temp[3] / sample_temp[0]) < 2.8f) ||
			((sample_temp[3] / sample_temp[1]) < 2.8f) ||
			((sample_temp[3] / sample_temp[2]) < 2.8f) )
		{
			_return = ERROR_7+0x80;
		}
		//---调试记录时间信息
#if (MODULE_LOG_MS1022>0)
		LOG_VA_ARGS("DOWN_TEST:T0:%.3f,T1:%.3f,T2:%.3f,T3:%.3f,RSSI:%.3f\r\n",
			sample_temp[0] * MS1022_HSE_CLOCK_MIN_WIDTH,
			sample_temp[1] * MS1022_HSE_CLOCK_MIN_WIDTH,
			sample_temp[2] * MS1022_HSE_CLOCK_MIN_WIDTH,
			sample_temp[3] * MS1022_HSE_CLOCK_MIN_WIDTH,
			MS1022x->msg_water_tof.msg_down_rssi);
#endif
	}
	else
	{
		_return += 0x80;
	}
	//---<<<读取下游时差
	return _return;
}

uint32_t temp_res[4] = { 0 };

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 获取第一波模式最佳偏置电压设置
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_get_offset(MS1022_HandleType* MS1022x)
{
	uint8_t _return = OK_0;
	uint8_t index = 0;
	//---状态寄存器的值
	uint32_t temp_state = 0;
	//---保存返回值
	//uint32_t temp_res[4] = { 0 };
	//---保存信号强度信息
	float temp_rssi[4] = { 0.0f };
	float swap_rssi = 0.0f;
	//--->>>通过第一波模式信号强度，验证型号强度---开始
	//---1. 设置波的触发电平+20mV
	//---2. 触发电平自动被设置到0mV
	//---3. 设置设置屏蔽窗口，比如设置到收到第5,6,7回波脉冲作为stop信号
	//---4. 计算第一个和第五个的脉冲宽度，计算比率，判断超声波信号的强度
#if (MODULE_LOG_MS1022>0)
	LOG_VA_ARGS("OFFSET:0mV\r\n");
#endif

	_return = ms1022_spi_read_start_tof_pre(MS1022x, &temp_state, MS1022_OFFSET_MV_P0);
	temp_res[0] = temp_state;
	//---计算平均信号强度
	if ((MS1022x->msg_water_tof.msg_up_rssi>0.3f)&&
		(MS1022x->msg_water_tof.msg_down_rssi>0.3f))
	{
		temp_rssi[0] = (MS1022x->msg_water_tof.msg_up_rssi + MS1022x->msg_water_tof.msg_down_rssi) / 2.0f;
	}
	else
	{
		_return |= 0x01;
	}

#if (MODULE_LOG_MS1022>0)
	LOG_VA_ARGS("OFFSET:5mV\r\n");
#endif

	_return = ms1022_spi_read_start_tof_pre(MS1022x, &temp_state, MS1022_OFFSET_MV_P5);
	temp_res[1] = temp_state;
	//---计算平均信号强度
	if ((MS1022x->msg_water_tof.msg_up_rssi > 0.3f) &&
		(MS1022x->msg_water_tof.msg_down_rssi > 0.3f))
	{
		temp_rssi[1] = (MS1022x->msg_water_tof.msg_up_rssi + MS1022x->msg_water_tof.msg_down_rssi) / 2.0f;
	}
	else
	{
		_return |= 0x02;
	}
#if (MODULE_LOG_MS1022 > 0)
	LOG_VA_ARGS("OFFSET:10mV\r\n");
#endif

	_return = ms1022_spi_read_start_tof_pre(MS1022x, &temp_state, MS1022_OFFSET_MV_P10);
	temp_res[2] = temp_state;
	//---计算平均信号强度
	if ((MS1022x->msg_water_tof.msg_up_rssi > 0.3f) &&
		(MS1022x->msg_water_tof.msg_down_rssi > 0.3f))
	{
		temp_rssi[2] = (MS1022x->msg_water_tof.msg_up_rssi + MS1022x->msg_water_tof.msg_down_rssi) / 2.0f;
	}
	else
	{
		_return |= 0x03;
	}
#if (MODULE_LOG_MS1022>0)
	LOG_VA_ARGS("OFFSET:15mV\r\n");
#endif

	_return = ms1022_spi_read_start_tof_pre(MS1022x, &temp_state, MS1022_OFFSET_MV_P15);
	temp_res[3] = temp_state;
	//---计算平均信号强度
	if ((MS1022x->msg_water_tof.msg_up_rssi > 0.3f) &&
		(MS1022x->msg_water_tof.msg_down_rssi > 0.3f))
	{
		temp_rssi[3] = (MS1022x->msg_water_tof.msg_up_rssi + MS1022x->msg_water_tof.msg_down_rssi) / 2.0f;
	}
	else
	{
		_return |= 0x04;
	}

#if (MODULE_LOG_MS1022>0)
	LOG_VA_ARGS("0mV_RSSI:%0.3f,0mV_STA:%X\r\n5mV_RSSI:%0.3f,5mV_STA:%X\r\n10mV_RSSI:%0.3f,10mV_STA:%X\r\n15mV_RSSI:%0.3f,15mV_STA:%X\r\n",
		temp_rssi[0], temp_res[0],
		temp_rssi[1], temp_res[1],
		temp_rssi[2], temp_res[2],
		temp_rssi[3], temp_res[3]);
	LOG_VA_ARGS("RES_STA:%X\r\n", _return);
#endif
	//---<<<通过第一波模式信号强度，验证型号强度---开始
	//---查找最大值
	if ((compare_double_word(temp_res,0x00230023,4)==OK_0)&&(_return==OK_0))
	{
		//---查找最大信号幅度值
		for (index = 0; index < 4; index++)
		{
			if (temp_rssi[index]>swap_rssi)
			{
				swap_rssi = temp_rssi[index];
				temp_state = index;
			}
		}
#if (MODULE_LOG_MS1022>0)
		LOG_VA_ARGS("FRSSI:%0.3f,FINDEX:%d\r\n",
			swap_rssi, temp_state);
#endif
		//---最终的灵敏度
		MS1022x->msg_water_tof.msg_up_rssi = temp_rssi[temp_state];
		MS1022x->msg_water_tof.msg_down_rssi = temp_rssi[temp_state];
		//---最佳偏置电压
		temp_state *= 5;
		temp_state << 8;
		//---重新设置偏置电压
		//---计算偏置电压的设置
		temp_state = ms1022_spi_calculate_offset(MS1022x, temp_state);
		temp_state |= 0x20004004;
		ms1022_spi_send_reg(MS1022x, 4, temp_state);
		ms1022_spi_send_reg(MS1022x, 5, 0x30000005);
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 读取飞行时间
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_read_start_tof(MS1022_HandleType* MS1022x)
{
	uint8_t _return = OK_0;
	uint8_t sample_index = 0;
	uint16_t sample_state = 0;
	uint16_t sample_integer = 0;
	uint32_t temp_reg = 0;
	float sample_temp[4] = { 0.0f };
	float samp_res[2] = { 0.0f };
	//---上游时差
	float samp_up_diff_time[MS1022_TOF_SAMPLE_MAX_NUM] = { 0.0f };
	//---下游时差
	float samp_down_diff_time[MS1022_TOF_SAMPLE_MAX_NUM] = { 0.0f };
	//---打开参考时钟
	MS1022_32KHZ_CLOCK_ENABLE();
	//---延时等待时钟稳定
	NOP(); NOP(); NOP(); NOP();
	NOP(); NOP(); NOP(); NOP();
	NOP(); NOP(); NOP(); NOP();
	NOP(); NOP(); NOP(); NOP();
	//---开启晶振
	ms1022_spi_fosc_enable(MS1022x);
	//---上电复位
	ms1022_spi_send_cmd(MS1022x, MS1022_CMD_POWER_ON_RESET);
	//---等待时钟稳定和数据稳定
	delay_task_us(800);
	//---初始化设置
	ms1022_spi_send_reg(MS1022x, 0, 0xF387E800);
	ms1022_spi_send_reg(MS1022x, 1, 0x21444001);
	ms1022_spi_send_reg(MS1022x, 6, 0xCEC06006);

	//---计算屏蔽窗口时间,屏蔽窗口的时间会影响测量结果
	//---粗略计算超声波传递的时间，屏蔽3个发射脉冲。
	temp_reg = ms1022_spi_calculate_delval(MS1022x, 
		(MS1022x->msg_water_transducer.msg_space_length*1000.0f/(MS1022x->msg_water_tof.msg_sound_speed/1000.0f))+
		MS1022_DIV_FIRE_MIN_WIDTH*3);
	temp_reg |= 0xA0000002;
	ms1022_spi_send_reg(MS1022x, 2, temp_reg);
	//ms1022_spi_send_reg(MS1022x, 2, 0xa01e0002);
	//---设置第一波模式,1024us溢出,溢出写入0xFFFFFFFF,第3,4,5个回波
	//ms1022_spi_send_reg(MS1022x, 3, 0xF0510303);
	//---设置第一波模式,4096us溢出,溢出写入0xFFFFFFFF,第3,4,5个回波
	ms1022_spi_send_reg(MS1022x, 3, 0xF8510303);
	//---开启脉冲宽度测量,增加额外的20mV偏置,设置比较器的值5mV,偏置电压25mV
	//ms1022_spi_send_reg(MS1022x, 4, 0x20004F04);
	temp_reg = ms1022_spi_calculate_offset(MS1022x, MS1022_OFFSET_MV_P0);
	temp_reg |= 0x20004004;
	ms1022_spi_send_reg(MS1022x, 4, temp_reg);
	ms1022_spi_send_reg(MS1022x, 5, 0x30000005);

	//---清楚中断标志
	//ms1022_spi_int_flag_clear(MS1022x);

	//---查找第一波模式的最佳偏置电压
	_return= ms1022_spi_get_offset(MS1022x);
	
	//---判断最佳偏置电压信息
	if (_return==OK_0)
	{
		//---清楚中断标志
		ms1022_spi_int_flag_clear(MS1022x);
		//---循环读取飞行时间
		for (sample_index = 0; sample_index < MS1022_TOF_SAMPLE_MAX_NUM; sample_index++)
		{
			//--->>>测试上游飞行时间---开始
			ms1022_spi_send_reg(MS1022x, 5, 0x30000005);
			//---初始化设备
			ms1022_spi_send_cmd(MS1022x, MS1022_CMD_INIT);
			//---启动时差测量
			//---上电复位设备
			ms1022_spi_send_cmd(MS1022x, MS1022_CMD_START_TOF);
			//---等待测量完成
			_return = ms1022_spi_int_flag_wait(MS1022x);
			//---清楚中断状态标志
			ms1022_spi_int_flag_clear(MS1022x);
			//---判断中断状态是否有效
			if (_return == OK_0)
			{
				//---解析读取状态寄存器的值
				sample_state = ms1022_spi_read_state(MS1022x);
				//---判断温度状态信息
				if ((sample_state&MS1022_STATE_TDC_MASK) != 0)
				{
					if ((sample_state&MS1022_STATE_PRECOUNTER_TIME_OUT) != 0)
					{
						//---14位粗值计数器溢出
						_return = ERROR_2;
					}
					else
					{
						//---TDC测量单元溢出
						_return = ERROR_3;
					}
					break;
				}
				//---如果状态寄存器为0
				if ((sample_state & 0x03) != 0x03)
				{
					//---3个结果寄存器数据获取失败
					_return = ERROR_4;
					break;
				}
				//---判断状态寄存器的信息
				if (_return == OK_0)
				{
					/*
					//---读取结果寄存器0
					ms1022_spi_read_reg(MS1022x, 0);
					//---计算整数部分
					sample_integer = MS1022x->msg_read_data_buffer[1];
					sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
					//---计算小数部分
					sample_temp[0] = MS1022x->msg_read_data_buffer[3];
					sample_temp[0] = ((uint16_t)sample_temp[0] << 8) + MS1022x->msg_read_data_buffer[4];
					//---计算实际值
					sample_temp[0] = sample_temp[0] / 65536.0f + sample_integer;
					//---读取结果寄存器1
					ms1022_spi_read_reg(MS1022x, 1);
					//---计算整数部分
					sample_integer = MS1022x->msg_read_data_buffer[1];
					sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
					//---计算小数部分
					sample_temp[1] = MS1022x->msg_read_data_buffer[3];
					sample_temp[1] = ((uint16_t)sample_temp[1] << 8) + MS1022x->msg_read_data_buffer[4];
					//---计算实际值
					sample_temp[1] = sample_temp[1] / 65536.0f + sample_integer;
					//---读取结果寄存器2
					ms1022_spi_read_reg(MS1022x, 2);
					//---计算整数部分
					sample_integer = MS1022x->msg_read_data_buffer[1];
					sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
					//---计算小数部分
					sample_temp[2] = MS1022x->msg_read_data_buffer[3];
					sample_temp[2] = ((uint16_t)sample_temp[2] << 8) + MS1022x->msg_read_data_buffer[4];
					//---计算实际值
					sample_temp[2] = sample_temp[2] / 65536.0f + sample_integer;
					*/
					//---读取结果寄存器3
					ms1022_spi_read_reg(MS1022x, 3);
					//---计算整数部分
					sample_integer = MS1022x->msg_read_data_buffer[1];
					sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
					//---计算小数部分
					sample_temp[3] = MS1022x->msg_read_data_buffer[3];
					sample_temp[3] = ((uint16_t)sample_temp[3] << 8) + MS1022x->msg_read_data_buffer[4];
					//---计算实际值
					sample_temp[3] = sample_temp[0] / 65536.0f + sample_integer;
					//---计算上游时差
					samp_up_diff_time[sample_index] = sample_temp[3];
				}
			}

			//---<<<测试上游飞行时间---结束

			//--->>>测试下游飞行时间---开始

			if (_return == OK_0)
			{
				//--->>>测试上游飞行时间---开始
				ms1022_spi_send_reg(MS1022x, 5, 0x50000005);
				//---初始化设备
				ms1022_spi_send_cmd(MS1022x, MS1022_CMD_INIT);
				//---启动时差测量
				//---上电复位设备
				ms1022_spi_send_cmd(MS1022x, MS1022_CMD_START_TOF);
				//---等待测量完成
				_return = ms1022_spi_int_flag_wait(MS1022x);
				//---清楚中断状态标志
				ms1022_spi_int_flag_clear(MS1022x);
				//---判断中断状态是否有效
				if (_return == OK_0)
				{
					//---解析读取状态寄存器的值
					sample_state = ms1022_spi_read_state(MS1022x);
					//---判断温度状态信息
					if ((sample_state&MS1022_STATE_TDC_MASK) != 0)
					{
						if ((sample_state&MS1022_STATE_PRECOUNTER_TIME_OUT) != 0)
						{
							//---14位粗值计数器溢出
							_return = ERROR_2 + 0x80;
						}
						else
						{
							//---TDC测量单元溢出
							_return = ERROR_3 + 0x80;
						}
						break;
					}
					//---如果状态寄存器为0
					if ((sample_state & 0x03) != 0x03)
					{
						//---3个结果寄存器数据获取失败
						_return = ERROR_4 + 0x80;
						break;
					}
					//---判断状态寄存器的信息
					if (_return == OK_0)
					{
						/*
						//---读取结果寄存器0
						ms1022_spi_read_reg(MS1022x, 0);
						//---计算整数部分
						sample_integer = MS1022x->msg_read_data_buffer[1];
						sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
						//---计算小数部分
						sample_temp[0] = MS1022x->msg_read_data_buffer[3];
						sample_temp[0] = ((uint16_t)sample_temp[0] << 8) + MS1022x->msg_read_data_buffer[4];
						//---计算实际值
						sample_temp[0] = sample_temp[0] / 65536.0f + sample_integer;
						//---读取结果寄存器1
						ms1022_spi_read_reg(MS1022x, 1);
						//---计算整数部分
						sample_integer = MS1022x->msg_read_data_buffer[1];
						sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
						//---计算小数部分
						sample_temp[1] = MS1022x->msg_read_data_buffer[3];
						sample_temp[1] = ((uint16_t)sample_temp[1] << 8) + MS1022x->msg_read_data_buffer[4];
						//---计算实际值
						sample_temp[1] = sample_temp[1] / 65536.0f + sample_integer;
						//---读取结果寄存器2
						ms1022_spi_read_reg(MS1022x, 2);
						//---计算整数部分
						sample_integer = MS1022x->msg_read_data_buffer[1];
						sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
						//---计算小数部分
						sample_temp[2] = MS1022x->msg_read_data_buffer[3];
						sample_temp[2] = ((uint16_t)sample_temp[2] << 8) + MS1022x->msg_read_data_buffer[4];
						//---计算实际值
						sample_temp[2] = sample_temp[2] / 65536.0f + sample_integer;
						*/
						//---读取结果寄存器3
						ms1022_spi_read_reg(MS1022x, 3);
						//---计算整数部分
						sample_integer = MS1022x->msg_read_data_buffer[1];
						sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
						//---计算小数部分
						sample_temp[3] = MS1022x->msg_read_data_buffer[3];
						sample_temp[3] = ((uint16_t)sample_temp[3] << 8) + MS1022x->msg_read_data_buffer[4];
						//---计算实际值
						sample_temp[3] = sample_temp[0] / 65536.0f + sample_integer;
						//---计算下游时差
						samp_down_diff_time[sample_index] = sample_temp[3];
					}
				}
			}
			//---<<<测试下游飞行时间---结束
		}
	}
	//---关闭晶振---降低功耗
	ms1022_spi_fosc_disable(MS1022x);
	//---上电复位设备
	ms1022_spi_send_cmd(MS1022x, MS1022_CMD_POWER_ON_RESET);
	//---关闭参考时钟
	MS1022_32KHZ_CLOCK_DISABLE();
	//---判断飞行时间的测量结果
	if (_return == OK_0)
	{
		//---升序排列上游飞行时间
		asc_sort_float(samp_up_diff_time, MS1022_TOF_SAMPLE_MAX_NUM);
		//---升序排列下游飞行时间
		asc_sort_float(samp_down_diff_time, MS1022_TOF_SAMPLE_MAX_NUM);
		//---计算上游飞行时间的平均值，去掉最大和最小的各4个
		samp_res[0] = calc_avg_float(samp_up_diff_time + 4, MS1022_TOF_SAMPLE_MAX_NUM - 8);
		//---计算下游飞行时间的平均值，去掉最大和最小的各2个
		samp_res[1] = calc_avg_float(samp_down_diff_time + 4, MS1022_TOF_SAMPLE_MAX_NUM - 8);
		//---计算上行飞行时间
		MS1022x->msg_water_tof.msg_up_time = samp_res[0] * MS1022_HSE_CLOCK_MIN_WIDTH / 3.0f;
		//---计算上游飞行时间
		MS1022x->msg_water_tof.msg_down_time = samp_res[1] * MS1022_HSE_CLOCK_MIN_WIDTH / 3.0f;
		//---计算飞行时间差
		MS1022x->msg_water_tof.msg_diff_time = ABS_SUB(MS1022x->msg_water_tof.msg_up_time, MS1022x->msg_water_tof.msg_down_time);
		//---计算水流的速度
		MS1022x->msg_water_transducer.msg_water_speed = (MS1022x->msg_water_transducer.msg_space_length*MS1022x->msg_water_tof.msg_diff_time*1000.0f)
			/ (MS1022x->msg_water_tof.msg_up_time*MS1022x->msg_water_tof.msg_down_time);
		MS1022x->msg_water_transducer.msg_water_speed *= 500.0f;

#if (MODULE_LOG_MS1022>0)
		LOG_VA_ARGS("======>>>TOF<<<======\r\n");
		LOG_VA_ARGS("RSSI:%0.3f,TUP:%.3f,TDOWN:%.3f,TDIFF:%.3f,WSPEED:.3f\r\n",
			MS1022x->msg_water_tof.msg_up_rssi, 
			MS1022x->msg_water_tof.msg_up_time,
			MS1022x->msg_water_tof.msg_down_time, 
			MS1022x->msg_water_tof.msg_diff_time,
			MS1022x->msg_water_transducer.msg_water_speed);
#endif
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_read_start_tof_restart(MS1022_HandleType* MS1022x)
{
	uint8_t _return = OK_0;
	uint8_t sample_index = 0;
	uint16_t sample_state = 0;
	uint16_t sample_integer = 0;
	uint32_t temp_reg = 0;
	float sample_temp[4] = { 0.0f };
	float samp_res[2] = { 0.0f };
	//---上游时差
	float samp_up_diff_time[MS1022_TOF_SAMPLE_MAX_NUM] = { 0.0f };
	//---下游时差
	float samp_down_diff_time[MS1022_TOF_SAMPLE_MAX_NUM] = { 0.0f };
	//---打开参考时钟
	MS1022_32KHZ_CLOCK_ENABLE();
	//---延时等待时钟稳定
	NOP(); NOP(); NOP(); NOP();
	NOP(); NOP(); NOP(); NOP();
	NOP(); NOP(); NOP(); NOP();
	NOP(); NOP(); NOP(); NOP();
	//---开启晶振
	ms1022_spi_fosc_enable(MS1022x);
	//---上电复位
	ms1022_spi_send_cmd(MS1022x, MS1022_CMD_POWER_ON_RESET);
	//---等待时钟稳定和数据稳定
	delay_task_us(800);
	//---初始化设置
	ms1022_spi_send_reg(MS1022x, 0, 0xF387E800);
	ms1022_spi_send_reg(MS1022x, 1, 0x21444001);
	ms1022_spi_send_reg(MS1022x, 6, 0xCEC06006);

	//---计算屏蔽窗口时间,屏蔽窗口的时间会影响测量结果
	//---粗略计算超声波传递的时间，屏蔽3个发射脉冲。
	temp_reg = ms1022_spi_calculate_delval(MS1022x,
		(MS1022x->msg_water_transducer.msg_space_length*1000.0f / (MS1022x->msg_water_tof.msg_sound_speed / 1000.0f)) +
		MS1022_DIV_FIRE_MIN_WIDTH * 3);
	temp_reg |= 0xA0000002;
	ms1022_spi_send_reg(MS1022x, 2, temp_reg);
	//ms1022_spi_send_reg(MS1022x, 2, 0xa01e0002);
	//---设置第一波模式,1024us溢出,溢出写入0xFFFFFFFF,第3,4,5个回波
	//ms1022_spi_send_reg(MS1022x, 3, 0xF0510303);
	//---设置第一波模式,4096us溢出,溢出写入0xFFFFFFFF,第3,4,5个回波
	ms1022_spi_send_reg(MS1022x, 3, 0xF8510303);
	//---开启脉冲宽度测量,增加额外的20mV偏置,设置比较器的值5mV,偏置电压25mV
	//ms1022_spi_send_reg(MS1022x, 4, 0x20004F04);
	temp_reg = ms1022_spi_calculate_offset(MS1022x, MS1022_OFFSET_MV_P0);
	temp_reg |= 0x20004004;
	ms1022_spi_send_reg(MS1022x, 4, temp_reg);
	ms1022_spi_send_reg(MS1022x, 5, 0x30000005);

	//---清楚中断标志
	//ms1022_spi_int_flag_clear(MS1022x);

	//---查找第一波模式的最佳偏置电压
	_return = ms1022_spi_get_offset(MS1022x);

	//---判断最佳偏置电压信息
	if (_return == OK_0)
	{
		//---清楚中断标志
		ms1022_spi_int_flag_clear(MS1022x);
		//---循环读取飞行时间
		for (sample_index = 0; sample_index < MS1022_TOF_SAMPLE_MAX_NUM; sample_index++)
		{
			//---初始化设备
			ms1022_spi_send_cmd(MS1022x, MS1022_CMD_INIT);
			//---启动时差测量
			//---上电复位设备
			ms1022_spi_send_cmd(MS1022x, MS1022_CMD_START_TOF_RESTART);
			//---等待测量完成
			_return = ms1022_spi_int_flag_wait(MS1022x);
			//---清楚中断状态标志
			ms1022_spi_int_flag_clear(MS1022x);
			//---判断中断状态是否有效
			if (_return == OK_0)
			{
				//---解析读取状态寄存器的值
				sample_state = ms1022_spi_read_state(MS1022x);
				//---判断温度状态信息
				if ((sample_state&MS1022_STATE_TDC_MASK) != 0)
				{
					if ((sample_state&MS1022_STATE_PRECOUNTER_TIME_OUT) != 0)
					{
						//---14位粗值计数器溢出
						_return = ERROR_2;
					}
					else
					{
						//---TDC测量单元溢出
						_return = ERROR_3;
					}
					break;
				}
				//---如果状态寄存器为0
				if ((sample_state & 0x03) != 0x03)
				{
					//---3个结果寄存器数据获取失败
					_return = ERROR_4;
					break;
				}
				//---判断状态寄存器的信息
				if (_return == OK_0)
				{
					/*
					//---读取结果寄存器0
					ms1022_spi_read_reg(MS1022x, 0);
					//---计算整数部分
					sample_integer = MS1022x->msg_read_data_buffer[1];
					sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
					//---计算小数部分
					sample_temp[0] = MS1022x->msg_read_data_buffer[3];
					sample_temp[0] = ((uint16_t)sample_temp[0] << 8) + MS1022x->msg_read_data_buffer[4];
					//---计算实际值
					sample_temp[0] = sample_temp[0] / 65536.0f + sample_integer;
					//---读取结果寄存器1
					ms1022_spi_read_reg(MS1022x, 1);
					//---计算整数部分
					sample_integer = MS1022x->msg_read_data_buffer[1];
					sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
					//---计算小数部分
					sample_temp[1] = MS1022x->msg_read_data_buffer[3];
					sample_temp[1] = ((uint16_t)sample_temp[1] << 8) + MS1022x->msg_read_data_buffer[4];
					//---计算实际值
					sample_temp[1] = sample_temp[1] / 65536.0f + sample_integer;
					//---读取结果寄存器2
					ms1022_spi_read_reg(MS1022x, 2);
					//---计算整数部分
					sample_integer = MS1022x->msg_read_data_buffer[1];
					sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
					//---计算小数部分
					sample_temp[2] = MS1022x->msg_read_data_buffer[3];
					sample_temp[2] = ((uint16_t)sample_temp[2] << 8) + MS1022x->msg_read_data_buffer[4];
					//---计算实际值
					sample_temp[2] = sample_temp[2] / 65536.0f + sample_integer;
					*/
					//---读取结果寄存器3
					ms1022_spi_read_reg(MS1022x, 3);
					//---计算整数部分
					sample_integer = MS1022x->msg_read_data_buffer[1];
					sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
					//---计算小数部分
					sample_temp[3] = MS1022x->msg_read_data_buffer[3];
					sample_temp[3] = ((uint16_t)sample_temp[3] << 8) + MS1022x->msg_read_data_buffer[4];
					//---计算实际值
					sample_temp[3] = sample_temp[0] / 65536.0f + sample_integer;
					//---计算上游时差
					samp_up_diff_time[sample_index] = sample_temp[3];
				}
			}

			//---<<<测试上游飞行时间---结束

			//--->>>测试下游飞行时间---开始

			if (_return == OK_0)
			{
				//---等待测量完成
				_return = ms1022_spi_int_flag_wait(MS1022x);
				//---清楚中断状态标志
				ms1022_spi_int_flag_clear(MS1022x);
				//---判断中断状态是否有效
				if (_return == OK_0)
				{
					//---解析读取状态寄存器的值
					sample_state = ms1022_spi_read_state(MS1022x);
					//---判断温度状态信息
					if ((sample_state&MS1022_STATE_TDC_MASK) != 0)
					{
						if ((sample_state&MS1022_STATE_PRECOUNTER_TIME_OUT) != 0)
						{
							//---14位粗值计数器溢出
							_return = ERROR_2 + 0x80;
						}
						else
						{
							//---TDC测量单元溢出
							_return = ERROR_3 + 0x80;
						}
						break;
					}
					//---如果状态寄存器为0
					if ((sample_state & 0x03) != 0x03)
					{
						//---3个结果寄存器数据获取失败
						_return = ERROR_4 + 0x80;
						break;
					}
					//---判断状态寄存器的信息
					if (_return == OK_0)
					{
						/*
						//---读取结果寄存器0
						ms1022_spi_read_reg(MS1022x, 0);
						//---计算整数部分
						sample_integer = MS1022x->msg_read_data_buffer[1];
						sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
						//---计算小数部分
						sample_temp[0] = MS1022x->msg_read_data_buffer[3];
						sample_temp[0] = ((uint16_t)sample_temp[0] << 8) + MS1022x->msg_read_data_buffer[4];
						//---计算实际值
						sample_temp[0] = sample_temp[0] / 65536.0f + sample_integer;
						//---读取结果寄存器1
						ms1022_spi_read_reg(MS1022x, 1);
						//---计算整数部分
						sample_integer = MS1022x->msg_read_data_buffer[1];
						sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
						//---计算小数部分
						sample_temp[1] = MS1022x->msg_read_data_buffer[3];
						sample_temp[1] = ((uint16_t)sample_temp[1] << 8) + MS1022x->msg_read_data_buffer[4];
						//---计算实际值
						sample_temp[1] = sample_temp[1] / 65536.0f + sample_integer;
						//---读取结果寄存器2
						ms1022_spi_read_reg(MS1022x, 2);
						//---计算整数部分
						sample_integer = MS1022x->msg_read_data_buffer[1];
						sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
						//---计算小数部分
						sample_temp[2] = MS1022x->msg_read_data_buffer[3];
						sample_temp[2] = ((uint16_t)sample_temp[2] << 8) + MS1022x->msg_read_data_buffer[4];
						//---计算实际值
						sample_temp[2] = sample_temp[2] / 65536.0f + sample_integer;
						*/
						//---读取结果寄存器3
						ms1022_spi_read_reg(MS1022x, 3);
						//---计算整数部分
						sample_integer = MS1022x->msg_read_data_buffer[1];
						sample_integer = (sample_integer << 8) + MS1022x->msg_read_data_buffer[2];
						//---计算小数部分
						sample_temp[3] = MS1022x->msg_read_data_buffer[3];
						sample_temp[3] = ((uint16_t)sample_temp[3] << 8) + MS1022x->msg_read_data_buffer[4];
						//---计算实际值
						sample_temp[3] = sample_temp[0] / 65536.0f + sample_integer;
						//---计算下游时差
						samp_down_diff_time[sample_index] = sample_temp[3];
					}
				}
			}
			//---<<<测试下游飞行时间---结束
		}
	}
	//---关闭晶振---降低功耗
	ms1022_spi_fosc_disable(MS1022x);
	//---上电复位设备
	ms1022_spi_send_cmd(MS1022x, MS1022_CMD_POWER_ON_RESET);
	//---关闭参考时钟
	MS1022_32KHZ_CLOCK_DISABLE();
	//---判断飞行时间的测量结果
	if (_return == OK_0)
	{
		//---升序排列上游飞行时间
		asc_sort_float(samp_up_diff_time, MS1022_TOF_SAMPLE_MAX_NUM);
		//---升序排列下游飞行时间
		asc_sort_float(samp_down_diff_time, MS1022_TOF_SAMPLE_MAX_NUM);
		//---计算上游飞行时间的平均值，去掉最大和最小的各4个
		samp_res[0] = calc_avg_float(samp_up_diff_time + 4, MS1022_TOF_SAMPLE_MAX_NUM - 8);
		//---计算下游飞行时间的平均值，去掉最大和最小的各2个
		samp_res[1] = calc_avg_float(samp_down_diff_time + 4, MS1022_TOF_SAMPLE_MAX_NUM - 8);
		//---计算上行飞行时间
		MS1022x->msg_water_tof.msg_up_time = samp_res[0] * MS1022_HSE_CLOCK_MIN_WIDTH / 3.0f;
		//---计算上游飞行时间
		MS1022x->msg_water_tof.msg_down_time = samp_res[1] * MS1022_HSE_CLOCK_MIN_WIDTH / 3.0f;
		//---计算飞行时间差
		MS1022x->msg_water_tof.msg_diff_time = ABS_SUB(MS1022x->msg_water_tof.msg_up_time, MS1022x->msg_water_tof.msg_down_time);
		//---计算水流的速度
		MS1022x->msg_water_transducer.msg_water_speed = (MS1022x->msg_water_transducer.msg_space_length*MS1022x->msg_water_tof.msg_diff_time*1000.0f)
			/ (MS1022x->msg_water_tof.msg_up_time*MS1022x->msg_water_tof.msg_down_time);
		MS1022x->msg_water_transducer.msg_water_speed *= 500.0f;

#if (MODULE_LOG_MS1022>0)
		LOG_VA_ARGS("======>>>TOF<<<======\r\n");
		LOG_VA_ARGS("RSSI:%0.3f,TUP:%.3f,TDOWN:%.3f,TDIFF:%.3f,WSPEED:.3f\r\n",
			MS1022x->msg_water_tof.msg_up_rssi,
			MS1022x->msg_water_tof.msg_up_time,
			MS1022x->msg_water_tof.msg_down_time,
			MS1022x->msg_water_tof.msg_diff_time,
			MS1022x->msg_water_transducer.msg_water_speed);
#endif
	}
	return _return;
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 获取温度
//////输入参	数:
//////输出参	数:
//////说		明:
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_get_temperature(MS1022_HandleType* MS1022x)
{
	return ms1022_spi_read_start_temperature(MS1022x);
}

///////////////////////////////////////////////////////////////////////////////
//////函		数:
//////功		能: 获取流量信息
//////输入参	数:
//////输出参	数:
//////说		明: 计算流速，计算体积流量
//////////////////////////////////////////////////////////////////////////////
uint8_t ms1022_spi_get_flow(MS1022_HandleType* MS1022x)
{
	//---获取超声波时差信息
	uint8_t _return= ms1022_spi_read_start_tof(MS1022x);
	//---判断时差获取结果
	if (_return==OK_0)
	{
		//---计算流速
		MS1022x->msg_water_transducer.msg_flow_speed = MS1022x->msg_water_tof.msg_down_time*MS1022x->msg_water_tof.msg_sound_speed;
		MS1022x->msg_water_transducer.msg_flow_speed *= MS1022x->msg_water_tof.msg_sound_speed;
		//---除以换能器的距离
		MS1022x->msg_water_transducer.msg_flow_speed /= MS1022x->msg_water_transducer.msg_space_length;
		MS1022x->msg_water_transducer.msg_flow_speed /= 2.0F;
#if (MODULE_LOG_MS1022>0)
		LOG_VA_ARGS("FLOW_SPEED:%.3f\r\n",
			MS1022x->msg_water_transducer.msg_flow_speed);
#endif
		//---计算体积流量
		MS1022x->msg_water_transducer.msg_flow_volume *= MS1022x->msg_water_transducer.msg_flow_speed;
		MS1022x->msg_water_transducer.msg_flow_volume *= CIRCLE_AREA(MS1022x->msg_water_transducer.msg_space_length);
#if (MODULE_LOG_MS1022>0)
		LOG_VA_ARGS("FLOW_VOLUME:%.3f\r\n",
			MS1022x->msg_water_transducer.msg_flow_volume);
#endif
	}
	return _return;
}